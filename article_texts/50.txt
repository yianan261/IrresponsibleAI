Decentralized business model based on the Ethereum blockchain

The DAO was a digital decentralized autonomous organization[5] and a form of investor-directed venture capital fund.[6] After launching in April 2016 via a token sale, it became one of the largest crowdfunding campaigns in history,[6] but it ceased activity after much of its funds were taken in a hack in June 2016.

The DAO had an objective to provide a new decentralized business model for organizing both commercial and non-profit enterprises.[7][8] It was instantiated on the Ethereum blockchain and had no conventional management structure or board of directors.[7] The code of the DAO is open-source.[9]

Christoph Jentzsch at the Festival of the Future (Festival der Zukunft) from 1E9 and Deutsches Museum (Munich, Germany on July 22nd 2022)

In June 2016, users exploited a vulnerability in The DAO code to enable them to siphon off one-third of The DAO's funds to a subsidiary account. The Ethereum community controversially decided to hard-fork the Ethereum blockchain to restore approximately all funds to the original contract. This split the Ethereum blockchain into two branches, each with its own cryptocurrency, where the original unforked blockchain continued as Ethereum Classic.[10]

By September 2016, the value token of The DAO, known by the moniker DAO, was delisted from major cryptocurrency exchanges (such as Poloniex and Kraken). The DAO had in effect become defunct.[11][12]

History [ edit ]

The open source computer code behind the organization was written principally by Christoph Jentzsch, and released publicly on GitHub, where other contributors added to and modified the code.[6] Simon Jentzsch, Christoph Jentzsch's brother, was also involved in the venture.[6]

The DAO was launched on 30 April 2016 with a website and a 28-day crowdsale to fund the organization.[13]

The token sale had raised more than US$34 million by 10 May 2016, and more than US$50 million-worth of Ether (ETH)—the digital value token of the Ethereum network—by 12 May, and over US$100 million by 15 May 2016.[13][14] On 17 May 2016, the largest investor in the DAO held less than 4% of all DAO tokens and the top 100 holders held just over 46% of all DAO tokens.[15] The fund's Ether value as of 21 May 2016 was more than US$150 million,[16] from more than 11,000 investors.[17]

As of May 2016, The DAO had attracted nearly 14% of all Ether tokens issued to date.[1]

On 28 May 2016 the DAO tokens became tradable on various cryptocurrency exchanges.[18][11][12]

A paper published in May 2016 noted a number of security vulnerabilities associated with The DAO and recommended that investors in The DAO hold off from directing The DAO to invest in projects until the problems had been resolved.[19] An Ethereum developer on GitHub pointed out a flaw relating to "recursive calls". On June 9 it was blogged about by Peter Vessenes, founder of the Blockchain Foundation.[20] By June 14, fixes had been proposed and were awaiting approval by members of The DAO.

On June 16, further attention was called to recursive call vulnerabilities by bloggers affiliated with the Initiative for CryptoCurrencies & Contracts (IC3).[21]

On June 17, 2016, the DAO was subjected to an attack exploiting a combination of vulnerabilities, including the one concerning recursive calls, that resulted in the transfer of 3.6 million Ether - around a third of the 11.5 million Ether that had been committed to The DAO - valued at the time at around $50 million.[2][22] The funds were moved into an account subject to a 28-day holding period under the terms of the Ethereum smart contract so were not actually gone.

Members of The DAO and the Ethereum community debated what to do next, with some calling the attack unethical but valid, since it did not violate DAO rules as coded, while others called for the Ether to be re-appropriated and/or The DAO to be shut down.[22][23] The DAO community manager, Griff Green, organized a volunteer group of coders known as The White Hat Group to recoup the funds in the other 500 wallets before they could also be hacked.[24] Eventually on July 20, 2016, the Ethereum network was hard forked to move the funds in The DAO to a recovery address where they could be exchanged back to Ethereum by their original owners.[25] However, some continued to use the original unforked Ethereum blockchain, now called Ethereum Classic.

In September 2016, Poloniex de-listed DAO trading pairs, followed by Kraken in December 2016.[11][12]

Operation [ edit ]

The DAO was a decentralized autonomous organization[26] that exists as a set of contracts on the Ethereum blockchain,[27] with no physical address or officials with formal authority. The theory underlying the DAO was that keeping operational power directly in the hands of owners, not delegated to managers, would ensure that invested funds would be used in the owners' best interests, thus solving the principal–agent problem.[28]

As an on-chain organization, The DAO claimed to be completely transparent, since everything was done by the code which anyone could see and audit.[29] However, the complexity of the code base and the rapid deployment of the DAO meant that neither the coders, the auditors, nor the owners could ensure the intended behavior of the organization, with the eventual attacker finding an unexpected loophole.[30]

The DAO was intended to operate as "a hub that disperses funds (currently in Ether, the Ethereum value token) to projects". Investors receive voting rights by means of a digital share token;[26] they vote on proposals submitted by contractors, and a group of curator volunteer make sure the projects are legal and the contractors properly identified before whitelisting them.[6] The profits from an investment will flow back to their stakeholders as specified in an on-chain smart contract.[3]

The DAO did not hold the money of investors; instead, the investors owned DAO tokens that gave them rights to vote on potential projects.[16] Anyone could pull out their funds by the time they first voted.[3]

The DAO's reliance on Ether allowed people to send their money to it from anywhere in the world without providing any identifying information.[16]

In order to provide an interface with real-world legal structures, the founders of The DAO established a Swiss-based company, "DAO.Link", registered in Switzerland as a limited liability corporation (Société à responsabilité limitée, SARL), apparently co-founded by Slock.it and Neuchâtel-based digital currency exchange Bity SA. According to Jentzsch, DAO.Link was incorporated in Switzerland because local law allowed it to "take money from an unknown source as long as you know where it's going."[6]

Marketing [ edit ]

In May 2016, TechCrunch described The DAO as "a paradigm shift in the very idea of economic organization. ... It offers complete transparency, total shareholder control, unprecedented flexibility, and autonomous governance."[26]

The group's logo featured a capital letter Đ.

Risks [ edit ]

In May 2016, the plan called for The DAO to invest Ether into ventures. It would back contractors and receive in return "clear payment terms" from contractors.[citation needed] The organizers promoted The DAO as providing investors with a return on their investment via those "clear payment terms" and they warned investors that there was a "significant risk" that the ventures funded by them may fail.

The risks included unknown attack vectors and programming errors.[27][31] Additional risks included the lack of legal precedents: it was unknown how governments and their regulatory agencies would treat The DAO's ventures and contracts. For example, legal systems might not acknowledge a corporate veil protecting investors from individual legal and financial liability for actions taken by The DAO and its contractors. It was unclear if The DAO was selling securities, which are highly regulated, and if so, what type of securities.[17]

The DAO has a democratized organizational structure so that control can be spread among members, with no official leadership or regulation. Normally, there is no way to recover funds if a member mistakenly transfers cryptocurrency to the wrong wallet, including in case of fraud.[32]

Additionally, to function in the real world, contractors would likely need to convert the invested Ether into national currencies. In May 2016, attorney Andrew Hinkes said that those sales of Ether would likely depress its market value.[citation needed]

The code behind The DAO had several safeguards against anyone capturing the voting rights of shareholders to win investments.[16] However, this would not prevent fraudulent or over-optimistic proposals. A paper cited a "number of security vulnerabilities".[19]

Proposals [ edit ]

Slock.it (a German Blockchain venture), and Mobotiq (a French electric vehicle start-up) were listed as seeking potential funding on the daohub.org website during the May "creation period". Both Jentzsch brothers were involved in Slock.it as well.[6]

Regulation [ edit ]

On 25 July 2017, the U.S. Securities and Exchange Commission published a report on initial coin offerings (ICOs) and The DAO, examining "whether The DAO and associated entities and individuals violated federal securities laws with unregistered offers and sales of DAO Tokens in exchange for 'Ether,' a virtual currency." The SEC concluded that DAO tokens sold on the Ethereum blockchain were securities and therefore possible violations of U.S. securities laws.[33]

References [ edit ]. "The involvement of the ethereum foundation in the DAO has been and is a mistake. As I see it ethereum is supposed to be the foundational infrastructure upon which a flurry of projects and experiments are supposed to blossom, and in order for them to blossom they need a foundation that is strong, and that has integrity in the face of challenges. The hard fork proposal is a compromise that ruins that integrity and signals that projects like the DAO can influence the underlying foundation to their own advantage. To me that is totally unacceptable and is a departure from the principles that drew me to ethereum.". In 2016 a grand idea made its way onto the Ethereum network. The Decentralized Autonomous Organization (The DAO) was created to operate like a venture capital fund for decentralized cryptocurrency projects. The DAO was built as a smart contract on the Ethereum blockchain and had a creation period that allowed investors to to a wallet address in exchange for DAO tokens, with 1 Ether worth 100 DAO tokens. The DAO managed to attract approximately $150M worth of Ether turning it into the biggest crowdfunding event ever seen in the cryptocurrency space.

The DAO

The DAO was a complex Smart Contract with a focus on fair, decentralized operations. In order to allow investors to leave the organization in the case of a disagreement, The DAO was created with an exit or a ‘split function’. This function allowed users to revert the involvement process and to have the Ether they had sent to The DAO returned. If someone wanted to leave The DAO, they would create their own Child DAOs, wait 28 days and then approve their proposal to send Ether to another address.

During its early days of operation there were warnings of security issues and even a community call for a moratorium, however, most of the security issues were not solved.

The Hack

On June 18, it was noticed that funds were leaving The DAO and the Ether balance of the smart contract was being drained. Around 3.6M Ether worth approximately $70M were drained by a hacker in a few hours. The hacker was able to get the DAO smart contract to return Ether multiple times before it could update its own balance. There were two main flaws that allowed this to take place, firstly the smart contract sent the Ether and then updated the internal token balance. Secondly, The DAO coders had also failed to consider the possibility of a recursive call that could act in such a way.

The hack resulted in the proposal of a soft fork that would stop the stolen funds from being spent, however, this never took place after a bug was discovered within the implementation protocol. This opened up the possibility of a hard fork with wider reaching implications.

The Hard Fork

A hard fork was proposed that would return all the Ether stolen The DAO in the form of a refund smart contract. The new contract could only withdraw and investors in The DAO could make refund requests for lost Ether. While it makes perfect sense to seek to reimburse the victims of the attack, the hard fork uncovered a number of arguments that are still prevalent in the world of cryptocurrency today.

Some opposed the hard fork and argued that the original statement of The DAO terms and conditions could never be changed. They also felt that the blockchain should be free from censorship and things that take place on the blockchain shouldn’t be changed even in the event of negative outcomes. Opponents of these arguments felt that the hacker could not be allowed to profit from his actions and that returning the funds would keep blockchain projects free from regulation and litigation. The hard fork also made sense as it only returned funds to the original investors and would also help to stabilize the price of Ether.

The Conclusion

The final decision was voted on and approved by Ether holders, with 89% voting for the hard fork and as a result, it took place on July 20 during the 1920000th block. The immediate result of this was the creation of which shares all the data on the Ethereum blockchain up until block 1920000.

The creation of Ethereum Classic showed that hard forks were very much possible and it can be said that the creation of the second Ethereum currency has had an influence on the creators of subsequent forks. It also became clear that while the DAO was great idea, it was not implemented correctly and in order to move forward successfully blockchain projects would have to implement rigid security protocols.. . The tragic combination of inevitable bugs and immutable code

Last week witnessed a catastrophic event in the Ethereum ecosystem, when The DAO, a smart contract less than two months old, began rapidly leaking funds to an unknown party. Looking at the current set of Ethereum contracts, filled with casinos and self-declared Ponzi schemes, this might not seem like a big deal. That is, until you learn that over 12 million units of ether, the Ethereum cryptocurrency, had been invested in The DAO by almost 20,000 people. That’s around 15% of all the ether in existence, valued at over $250 million on June 17th.

Two days later, The DAO’s assets dipped below $100 million. Two things contributed to this precipitous fall. First, a third of its funds (as denominated in ether) had already been taken. And second, the resulting panic sent the market price of ether crashing down from its peak of over $21 to a more sobering $10.67. (At the time of publication, the price had recovered to around $14.) This second effect was a natural consequence of the first, since much of ether’s recent increase in value was driven by people buying it to invest in The DAO.

The DAO had promised to act as a new type of decentralized crowdsourcing vehicle, like Kickstarter or Indiegogo but without the middleman and regulation. It was designed to let participants pool their cryptocurrency, collectively vote on projects looking for funding, then invest and reap the future rewards. Before catastrophe struck, over 100 projects had already been proposed, most of which were related to Ethereum itself. In addition, The DAO allowed participants to withdraw their uninvested funds at any time, positioning itself as a low risk investment.

Ironically, the individual or group which drained The DAO did so by exploiting subtle errors in this withdrawal mechanism. Like all smart contracts in Ethereum, The DAO is just a piece of computer code, which is “immutably” (i.e. permanently and irreversibly) embedded in the blockchain and executed by every node in response to incoming transactions. And like any self-respecting smart contract, The DAO provides full transparency by making its source code easily accessible online. This means that anybody can independently verify its functionality but also, crucially, look for vulnerabilities. And yet, the immutable nature of blockchains prevents any such problems from being fixed.

At the end of May, several critical issues were highlighted on the outstanding Hacking Distributed blog, alongside a call for a moratorium on project proposals for The DAO. This is what we might call the ‘white hat’ approach, in which exploits are reported for the good of the community. Nonetheless nobody seemed too worried, as the problems related to skewed economic incentives rather than a risk of outright theft. Simultaneously, however, it appears that others were poring over The DAO’s code with greater self-interest – namely, to look for a way to make a ton of money. And on June 17th, someone succeeded.

Draining The DAO

In a general sense, the attack arose from the interaction between vulnerabilities in The DAO’s code and other code which was designed to exploit them. You see, when looked at in isolation, The DAO did not contain any obvious mistakes, and indeed it was only released after an extensive security audit. But with the benefit of hindsight and many more eyes, a significant number of errors have since been found.

I won’t provide a full technical description of the exploit’s mechanism here, since others have already published superb and detailed post mortems (see here, here and here). But I will explain one particular vulnerability that was present, because it has been discovered in many other smart contracts and serves as an instructive example.

Let’s say that a smart contract holds funds on behalf of a number of users, and allows those users to withdraw their funds on request. The logic for the process might look something like this:

Wait for a user to request a withdrawal. Check if that user’s balance is sufficient. If so, send the requested quantity to the user’s address. Check that the payment was successful. If so, deduct the quantity from the user’s balance.

This all looks eminently sensible, and rather like an ATM which gives you some cash and deducts the appropriate amount from your bank balance.

So how can this simple process go wrong? Well, it turns out that if an Ethereum address belongs to a contract rather than a regular user, then this contract can run some code in response to receiving funds. And this code can, in turn, trigger other pieces of code on the Ethereum blockchain. Crucially, it can even trigger the same piece of code that caused it to be paid in the first place.

This means that, during step 3 above, the receiving address can send a new request for withdrawal, beginning a new process at step 1 before the previous process has completed. Since the user’s balance is only reduced in step 5, a new withdrawal will be approved based on the previous balance, and the same amount will be paid out again. In response to this second payment, the receiving contract can request a third, and then a fourth, and so on until the funds are drained or some other limit is reached. At this point, the user’s balance will finally be reduced by the appropriate amount, entering the negative territory which step 2 was supposed to prevent.

The equivalent would be an ATM which delivers banknotes that trigger a free repeat withdrawal when waved at the screen. The first customer to find out could empty the ATM entirely.

This ability for a piece of code to wind up calling itself is called recursion, and is a very useful technique in general computer programming. However in the case of The DAO, it paved the way for this ruinous exploit. Nonetheless, if this had been the only problem, the attack’s potential would have been contained, because Ethereum applies a limit on how deeply recursion can occur. Unfortunately, several further bugs in The DAO amplified the effects, leading to the eventual loss of tens of millions of dollars.

Of course, if just a few lines of The DAO’s code had been written differently, none of this could have happened. For example, in the 5-step process above, if the user’s balance is reduced before the funds are sent, then recursive calling would be perfectly safe. But sadly, even if its creators’ intentions were pure, The DAO’s actual code was deeply flawed. And computers have a nasty habit of blindly following the instructions they are given, even if a five year old can see that the results don’t make sense. Having been embedded immutably in the Ethereum blockchain, the faulty DAO was granted stewardship over hundreds of millions of dollars by a horde of naïve investors, and then spectacularly went up in flames. The DAO turned out to be a complete and utter shambles, and it can never be fixed.

The trouble with code

Tempting as it might be, I’m not here to haul The DAO’s programmers over the technical coals. Looking at the underlying source code, it seems reasonably well architected, with good function and variable names and clear internal documentation. While none of this proves its quality, there tends to be a high correlation between how code looks and how well it functions, for the same reason that CVs with poor punctuation warn of sloppy employees. In any event I don’t doubt that The DAO’s authors are competent developers – indeed, the fact that it passed an extensive code review suggests that the basic logic was sound.

So if the problem is not the people who worked on this project, or the work they produced, what is it? It is the fact that writing large pieces of bug-free code is extremely hard, if not impossible. I’ve worked with some truly outstanding programmers in my career, the sort who can crank out code at ten times the average developer’s pace, and with ten times fewer defects. And yet, even these remarkable individuals make mistakes which lead to software malfunctions. Donald Knuth, possibly the greatest computer programmer of all time, made a famous promise to provide an exponentially increasing financial reward to each person who found a bug in his TeX typesetting software. And he’s sent out more than a few checks.

To be clear, I’m not talking about silly slip-ups with names like “off-by-one”, “uninitialized variable” and “operator precedence”. These often cause a visible failure the first time a program is run, and can be easily spotted by reviewing the local piece of code in which they reside. And I’m not even talking about security vulnerabilities like “unvalidated inputs”, “SQL injection” and “buffer overflows”, which might not show up in a program’s regular usage, but should nonetheless be front of mind for every experienced developer.

Rather, I’m talking about trickier problems like “race conditions” and “deadlocks”. These arise from conflicts between parallel processes and tend to only show up intermittently, making them hard to detect and reproduce. As a result, they can only be understood by considering a system as a whole and how its constituent parts interact. This is much harder than regular programming, because it requires developers to think beyond the individual piece of code that they’re working on. It’s not unusual for coders to spend several days “debugging” in order to nail one of these problems down. And this is precisely the sort of holistic thinking that was needed to foresee how The DAO might be vulnerable.

With all of these difficulties, one might legitimately wonder why our increasingly code-driven world isn’t crumbling around us. Luckily, most software has three critical factors working in its favor – gradual adoption, regular updates and time.

Here’s how it works: A new software product is created to answer an emerging market need. At first, the market is small, so only a few people know they need the product. And since the product is new, an even smaller number of them will actually find it. These “early adopters” are a brave and hardy bunch who enjoy living on the technological edge, despite the associated risks. So they try out the new product, see some stuff they like, ask for a bunch of things that are missing and, best of all, report any problems encountered. Every good software entrepreneur knows to shower these people with love and assistance, and thank them for every single morsel of feedback they provide. Because while it sucks to hear about a defect in your product, it sucks a lot more not to hear about it.

Ideally, within a month or less, a new version of the product is released, fixing the reported bugs and adding some requested features. The early adopters are happy and more feedback flows in, as the latest version is put through its paces, and round it goes again. As the market grows, the number of people using the product increases. And as the product steadily improves, more and more of these people tell others about it. Even better, the more people that use the product, the more likely it is that someone, somewhere, will create that precise and unlikely situation in which an obscure bug will appear. With a bit of luck, they will let you know, and you will scratch your head in disbelief, ask for more information, eventually find and resolve the problem, and breathe a sigh of relief.

With few exceptions, this is how today’s software development works, because it is the most efficient way to create outstanding products. Of course, a good software team will also develop an extensive internal test suite, to catch as many errors as possible before they reach users, and ensure that new versions don’t break anything that previously worked. But still, most of us also rely on our user bases, because there is simply no way that we can afford to imagine and test every possible way in which our products might be used. And if you think this doesn’t apply to the big guys, you couldn’t be more wrong. How many “automatic updates” have been downloaded to your Windows, Mac or Linux system in the past year? And if you’re using Chrome or Firefox, your web browser now updates itself automatically and silently, an average of once per month.

This iterative process takes considerable time, by which I mean a few years or more. Still, after a product has been in development for long enough, and its user base has grown large enough, and those users have been (unknowingly) testing it in enough different situations, something magic happens. This magic is called “maturity”, and it’s what every software product must strive to achieve. Maturity means that a product works really well for pretty much everybody that uses it, and there are no shortcuts to getting there. But if you get the timing right, your product will mature at around the time that your target market coalesces, i.e. when large numbers of customers are actually willing to stump up and pay for it. And then, as they say, verily shall ye profit.

On immutable code

So here we come to the fundamental problem with smart contracts, as demonstrated so forcefully by The DAO:

By design, smart contracts are immutably embedded in a blockchain, and so cannot be updated. This prevents them from reaching maturity.

In previous posts, I’ve discussed other problems with smart contracts, such as their effect on blockchain performance and the fact that they are less powerful than many people imagine. For these and other reasons, we have not (yet) implemented smart contracts in the MultiChain blockchain platform. But until I witnessed the failure of The DAO, I hadn’t given enough thought to a much more fundamental issue: any non-trivial smart contract is likely to contain defects that cannot be fixed.

For the modern software developer, unfixable code is an out-and-out nightmare, setting the bar higher than most are able to reach. But we do encounter this kind of code in some situations, such as the design of the microprocessors which lie at the heart of every computer and smartphone. This code, written in languages like Verilog and VHDL, defines the physical layout of a silicon chip, which cannot be changed once manufactured. In situations like these, we tend to see several characteristics: (a) the code is written in a language that was designed with safety in mind, (b) large numbers of people work on it for several years, (c) it is subject to extensive automated testing and formal verification, and (d) if the final product is shipped with a defect, the cost of a recall falls squarely on the shoulders of the party responsible (see for example the infamous Pentium bug).

It goes without saying that none of this applies to the creators of The DAO, or indeed any other smart contract. But code immutability isn’t the only challenge for smart contract developers. A number of other factors conspire to make Ethereum considerably more dangerous than most computing environments:

As discussed earlier, most contracts reveal their source code, to gain the trust of potential users. This makes bugs easy to find and exploit. While regular code can be fixed when a problem is found, with immutable code only attackers get to benefit.

As in most programming languages, one “function” (piece of code) on the blockchain is able to “call” (trigger) another, to create cascading effects. However Ethereum is unusual in enabling direct function calls between the code written by parties who do not know each other and whose interests may collide. This is a perfect recipe for adversarial and unexpected behavior.

As mentioned previously, if one Ethereum contract sends funds to another, the latter has the opportunity to execute some code in response. This code can be deliberately designed to cause the send operation to fail, potentially triggering all sorts of further havoc.

When one function calls another, and this second function calls a third, a “stack” of calls and sub-calls is created. Keeping track of this stack carries a computational cost, so Ethereum includes a “call stack limit” which restricts how deep it can go. This is fair enough. But if the limit is reached by a particular function call, the Ethereum environment silently skips that call, rather than safely terminating the entire transaction and unwinding its effects. In other words, some code in a smart contract just might not be executed, and this non-execution can be deliberately caused by triggering that contract from a sufficiently deep stack. This strikes me as a truly abominable design choice, breaking the mental model that every software developer is accustomed to. Whoever made this decision probably should be hauled over the coals, though there is thankfully now a suggestion to change it.

Ethereum also has a “gas limit”, which prevents abuse in public blockchains by making transactions pay for the computational resources they consume. The sender of a transaction decides how much gas they are willing to spend, and if this runs out before the transaction completes, it is safely aborted. While this is probably the best solution to a difficult problem, it can have unpleasant consequences. Some contracts turn out to need more gas than anticipated, while others cannot be run at all.

The public Ethereum network’s cryptocurrency allows defects in smart contracts to send real money to the wrong place, with no easy method of recovery. While Ethereum miners seem to be voting in favor of a “soft fork” to freeze the funds drained from The DAO, this is not a sustainable solution.

To summarize, compared to regular centralized computer systems, Ethereum is a much more tricky environment to code for safely. And yet its principle of immutability serves to prevent buggy software from being updated. In other words, smart contracts are software whose bugs are visible, cannot be fixed, and directly control real people’s money. This, rather obviously, is a highly toxic mix.

Proponents of Ethereum-style smart contracts in private blockchains might be tempted to celebrate The DAO’s demise, but I don’t think this response is merited. With the exception of the last two points above, all of the issues with Ethereum apply equally to permissioned blockchains, which still rely on immutable smart contracts – although in this case the immutability is guaranteed by a group of identified parties rather than anonymous miners. If you want to claim that private blockchains allow buggy smart contracts to be more easily rewound, replaced or ignored, then what you’re really saying is that smart contracts serve no purpose in these blockchains at all. Put simply, if something is not meant to be immutable, it shouldn’t be stored in a blockchain. Instead, stick to good old fashioned legal documents and centralized application logic, using the chain for: (a) immutably storing the data on which that logic depends, and (b) representing the final consensual outcome of applying it. (This design pattern has been named Simple Contracts by others.)

Nonetheless the risks in the public Ethereum network are undoubtedly worse, because badly written smart contracts can rapidly and irreversibly send large amounts of real value (in the form of cryptocurrency) to users whose identity is unknown. Indeed, is there any better way for an evil genius to make a killing than: (a) writing a smart contract which looks right and fair, (b) allowing it to run safely and consistently for several years, (c) waiting for it to accumulate a large sum of money from investors, and then (d) triggering some obscure vulnerability to siphon off those funds. While I’m not suggesting that The DAO’s failure was deliberate, it will surely inspire others to make similar “mistakes”.

If I had to summarize the factors underlying Ethereum’s design, I might use the phrase “inexperienced genius”. Genius, because I believe it is a genuinely brilliant invention, adding two key innovations to the cryptocurrency systems that came before: (a) the Ethereum Virtual Machine which executes smart contracts and its method for assigning cost to computation, and (b) the use of Patricia trees to enable compact proofs of any aspect of a blockchain’s state. And yet, inexperienced as well, because some of Ethereum’s design choices are so obviously terrible, such as the silent-but-violent call stack limit, or the ability of a payment recipient to recursively trigger the code which paid it.

None of this would be a problem if Ethereum was being treated as an experiment, worthy of exploration but with critical issues remaining to be resolved. The equivalent perhaps of bitcoin during its first couple of years, when its total market capitalization didn’t go beyond a few million dollars. Unfortunately, as a result of speculation and inflated expectations, Ethereum hasn’t been given the same opportunity to find its proverbial feet. Instead, at less than one year old, it’s carrying a billion dollars in market value. Ethereum is like a toddler being forced to cook dinner, or an economics freshman chairing the Federal Reserve. I believe it’s time to recognize that the immaturity problem of individual smart contracts also applies to Ethereum as a whole.

Ethereum’s way forward

While I’m yet to see strong use cases for smart contracts in private or permissioned blockchains, I think they probably do have a place in public chains with associated cryptocurrencies. That is, if you accept the basic premise of censorship-free financial systems, which help the financially excluded and ransomware authors in equal measure. Putting this debate aside, there is certainly technical merit in a cryptocurrency which supports arbitrary logic, of the sort that cannot be implemented on “first generation” blockchains like bitcoin. For now at least, Ethereum is the first and only convincing attempt to build such a system, with a ton of money and momentum behind it.

Nonetheless, as a developer ecosystem, Ethereum appears to be fundamentally broken. While The DAO is its most costly and high profile failure, many other contracts are suffering from similar problems. So how can Ethereum clean up its act?

Send a clear message that, at least for the next two years, nobody should send any funds to a smart contract unless they are happy to lose them in the name of self-education.

Fix some glaring issues with the Ethereum Virtual Machine (“EVM”), namely: (a) removing the call stack limit, (b) providing a way to send ether without triggering code, and (c) allowing contracts to be marked as “non-reentrant”, meaning that their functions cannot be called while they are already in the middle of something.

Develop a new programming language for smart contracts, which uses a more restrictive method for expressing computation that is amenable to formal proofs of correctness. Decades of research have already been invested in this field, so there is much existing work to be leveraged. (This won’t require changes to the EVM itself, since the chosen language could still be compiled into regular “bytecode”.)

Build up an official set of secure smart contracts and functions, which have been peer-reviewed to death and proven themselves reliable in many different situations. This is akin to the standard libraries that are available for many mature programming languages. (Though at this point it’s tempting to ask: why not just hard-code the functionality of these libraries into the EVM, and enjoy much better performance as a result? Answer: Because Ethereum was specifically designed to move away from blockchains with hard-coded feature sets. But still, it does make you wonder.)

The current option, of manually intervening in response to the failure of specific smart contracts, will not be viable on a larger scale if Ethereum is to maintain its identity as a trustless and decentralized computing platform. Indeed, some make a credible case that this single judgment-based act of governance has already destroyed Ethereum’s reputation. And we should note that The DAO’s terms and conditions explicitly state that nothing “may modify or add any additional obligations or guarantees beyond those set forth in The DAO’s code”. In other words, whoever drained The DAO was acting in accordance with its published terms, and is therefore presumably on the right side of the law.

We must also accept the possibility that, after several more years of good work, Ethereum might still prove too difficult for developers to work with safely. In that case, it will languish as a matchmaking service between anonymous scammers and their foolish marks. But that wouldn’t mean it was a waste of time – at the very least, Ethereum is a fascinating experiment, from which the blockchain community will learn a lot.

In the meantime, for users of private blockchains, I can only repeat what I’ve said before:

If your application doesn’t require smart contracts, then use a simpler blockchain architecture.

Whereas this advice was previously justified in terms of performance, it is now reinforced by the apparent difficulty of getting smart contracts right. And if you’re not sure whether your use case requires smart contracts, feel free to email us with some details, and we’ll be happy to let you know.

Please post any comments on LinkedIn.. The New Kid on the Block

The Decentralized Autonomous Organization (DAO) was set to become the first digital decentralized investment fund. Virtually all its daily operations would be handled, well, virtually. This includes investment plans, payments, and even the corporate governance—all of it is determined by code. Its crowd investment in May 2016 turned out to be the most successful crowd funding campaign ever, passing the previous world record held by the video game Star Citizen.

The DAO had no branch offices and no employees. It performed the duty of managing the crowdfunded investment via so-called Smart Contracts based on the Ethereum-Blockchain. Started in 2013, Ethereum uses the Blockchain to store data permanently in public storage and move it around easily and fast. Ethereum provides the infrastructure to set up Smart Contracts: agreements represented and carried out by a software that emulates the logic of traditional financial contracts.

The DAO used Smart Contracts as a replacement for contracts between investors and startups. Everyone could be an anonymous investor by buying Ether, the cryptocurrency of the Ethereum-Blockchain, and with Ether purchase DAO tokens, which are similar to a corporate share. Each investor could then decide to invest into a startup by sending a number of DAO tokens to the respective proposal. The startups can then exchange the token into Ether and later, if necessary, into traditional fiat currency. Smart Contracts would have carried out all of the aforementioned administration processes.

A Hack Hits Home

However, the promise of a new era of startup investing (beyond that of conventional venture capitalists and angel investors) seemed to be destroyed on June 17th, when a hacker took advantage of some of the code of The DAO’s smart contracts and managed to steal 3,6 Million Ether (50 Million USD at the time).

Fortunately for DAO investors, a waiting period for the withdrawal of funds was programmed into the Smart Contract, which the hacker had to abide by before they could exchange their stolen Ether into offline currency. This gave the DAO investors precious time to find a solution to save their investment.

Following heated debates in the Blockchain community, a majority of the fledgling DAO-network agreed to create an alternative version of the Blockchain on which the hack had never happened.

Now the Ethereum-Blockchain exists in two instances. One is the Ethereum Hard Fork (ETH) Blockchain where the hack was made undone. The other is the untouched, but hacked, Ethereum (ETC), which was intended to sink into oblivion and out of use. However, Blockchain-fundamentalists within the cryptocurrency community decided they had other plans: “Code is law”, they maintained, and “If the code of the DAO allowed this hack, the hack is legit”. These fundamentalists continue to operate the ETC Blockchain despite the immediate financial downside for all DAO investors. Strengthening the fundamentalist position, the cryptocurrency exchange Poloniex, was first to list ETC on its exchange, maintaining the liquidity of ETC.

Sadly, before the DAO had a chance to realize its vision of fluid and open investment funds, it turned into a bickering two-headed monster. With ETH a refund has been established where DAO-investors can get their investments back and on ETC the hacker still owns his stolen Ether.

A Legal Gambit

It has been some four months since the hack of the DAO. The months following the hack were turbulent, with the rescue of the investment capital contributing to a split in the blockchain and the corresponding, yet unwanted, doubling of the investment fund and its capital deposits.

During the DAO’s crowd investment campaign, the legal liability of the DAO didn’t seem to bother backers much; however, that changed after the June 17th hack. Suddenly, the question of legal liability became rather pressing.

“Whereas in a legal regime, contracts are enforced by a court, in a blockchain regime, contracts are automatically enforced by the entire network,” explains Florian Glatz, a Berlin based lawyer specializing in blockchain legality. “Therefore, organizations like The DAO do not need to have a legal personality to operate. On the other hand, the people building, investing and working with DAOs are very much members of our established legal systems.”

Regulators are only just beginning to take the first steps to consider blockchain regulation. In May of 2016, the European Parliament approved a proposal to dedicate a task force to digital currencies and blockchain-technology. However, the proposal clearly mandates a hands-off approach with minimal to no regulations suggested during the early stages of the blockchain’s life.

In September 2016, the US House of Representatives passed a non-binding resolution calling on the US government to craft a national technology policy that includes digital currencies and blockchain-technology.

But the question remains—how can smart contracts be interwoven with the same rules and regulations that govern the very real financial world? Up to now, intermediaries such as banks allow regulators to enforce policy choices, whereas the key feature of the blockchain is that there are no more intermediaries to begin with.

A further hurdle to cryptocurrency regulation is that Smart Contracts-run organizations are not comparable with classical legal entities found in the business world. Blockchain-companies do not currently register themselves in legally recognized ledgers, nor has it been decided if DAO tokens (similar to corporate shares) are financial products that fall under standing financial regulations.

A Way Forward?

Glatz suggests that, in the near future, groups organized as DAOs that interact with physical or even just intellectual assets, will have to find ways to establish a complementary legal counterpart to their virtual company form. “First attempts are based on non-profit foundations holding funds as impartial, classically-regulated intermediaries. In the mid-term future, capital market regulation will be adapted to fit blockchain-based investment schemes.”

Obviously, there is rising concern more regulation that exists for blockchains, the higher the threshold will be for organizations to use blockchain. In a world where cryptocurrency is regulated, innovations such as The DAO likely would have never happened.

Glatz suggests the novel technique of “regulatory sandboxes” as a potential path forward to allow for grassroots movements such as The DAO ecosystem, while ensuring that those businesses, which reach a mass market audience, transition into a fully regulated state eventually. “In the near to midterm future, jurisdictions that offer such a sandbox model for startups, will attract the most disruptive firms.” The UK and Singapore are two countries fostering such a startup-friendly environment.. . . . More than two years after the collapse of The DAO thrust the Ethereum community into civil war, one of the bugs that caused that caused that black swan event continues to lurk in many smart contracts, waiting to be exploited by hackers.

That’s according to Emin Gün Sirer‏, a computer science professor at Cornell and the co-director of cryptocurrency research initiative IC3, who said that he has seen a variety of smart contracts that may be vulnerable to a “reentrancy ” attack that allows a malicious user to drain ETH from a payment channel.

“BTW, I’ve seen other contracts like this one that implicitly trust the erc-20 tokens issued on top of their platform to not perform reentrant calls. I’m sure this isn’t the last episode of this bug,” he wrote on Twitter.

Sirer was commenting on the news that SpankChain, an adult entertainment startup whose platform runs partially on Ethereum smart contracts, had been hacked for nearly $40,000 worth of cryptocurrency over the weekend.

As CCN.com reported, the company said that the hacker used a reentrancy attack to siphon 1165.38 ETH out of the smart contract over a series of transactions. In short, the attacker used a malicious smart contract to trick the SpankChain contract into believing that the attacker could withdraw funds from the payment channel.

The firm explained:

“The attacker created a malicious contract masquerading as an ERC20 token, where the ‘transfer’ function called back into the payment channel contract multiple times, draining some ETH each time.”

As both Spankchain and Sirer noted, the attack was similar to the one that crippled The DAO, a decentralized venture capital fund that long held the record for most funds raised by an initial coin offering (ICO).

Worth as much as $150 million at a time when the total market cap of ethereum was still far below $2 billion, The DAO held nearly 15 percent of the total ETH supply on June 17, 2016, when an attacker stole 3.6 million ETH — today worth nearly $815 million — by exploiting its vulnerable smart contract.

We all know what happened next: a series of futile attempts to recover the funds, the infamous chat room conversation , and the contentious hard fork that resulted in the creation of Ethereum Classic.

Now, more than two years later, Ethereum has largely put The DAO hack in its rearview mirror. The ethereum price, which plunged as low as $6 in the months following the hack, now stands at $230. Hundreds of blockchain startups have used Ethereum to raise billions of dollars through ICOs, and thousands of developers are building decentralized applications (dApps) that run on the platform.

However, though the consequences may not always be quite as serious as they were on that infamous morning in June 2016, the bug that permanently altered the cryptocurrency landscape appears determined to continue to rear its ugly head.

Images from Shutterstock. One of the design goals of Ethereum was to simplify the specification of the consensus layer. That’s a noble goal, as it facilitates the re-implementation of the platform for different programming languages and constraints. But even if the minimum subset of instructions that enables Turing complete smart contracts is below 10, Ethereum did not limit itself to such minimal instruction set, for several reasons: (a) It reduces the performance considerably (b) it makes compiled code difficult to audit. So Ethereum has about 100 different opcodes. However it seems that for the sake of minimization the CALL opcode was overloaded with two functions: call a method of another contract, and send ether. But the semantics of these two functions and the contexts where each of these functions being used is very different. This lack of education was one of the factors that also led to the DAO hack. It is interesting to note that indirectly the VM already provides a mean to send ether without calling any function, by creating a temporary contract and using the suicide opcode, albeit with a much higher gas cost. This option leads to the simple conclusion that the VM should offer a SEND opcode that does not call any code, reducing the complexity of upper layers. One can argue that limiting the amount of gas offered for the call to 2300 gas has the side-effect that no other CALL can be performed, so it’s safe. This argument is false if we consider that the VM may later undergo hard-forks that may: reduce the cost of a CALL operation, or allow contracts to pay for its gas. So basically that solution is shortsighted, hides the real problem to the user and prevent future improvements. At RSK we’ve implemented a simple SEND opcode that does not call any code in the destination contract.. The Story of the DAO — Its History and Consequences Samuel Falkon · Follow Published in The Startup · 5 min read · Dec 24, 2017 -- 8 Listen Share

One of the most incredible concepts to be successfully implemented through blockchain technology is the DAO, a decentralized autonomous organization. Decentralized autonomous organizations are entities that operate through smart contracts. Its financial transactions and rules are encoded on a blockchain, effectively removing the need for a central governing authority — hence the descriptors “decentralized” and “autonomous.”

The Decentralized Autonomous Organization (known as The DAO) was meant to operate like a venture capital fund for the crypto and decentralized space. The lack of a centralized authority reduced costs and in theory provides more control and access to the investors.

At the beginning of May 2016, a few members of the Ethereum community announced the inception of The DAO, which was also known as Genesis DAO. It was built as a smart contract on the Ethereum blockchain. The coding framework was developed open source by the Slock.It team but it was deployed under “The DAO” name by members of the Ethereum community. The DAO had a creation period during which anyone was allowed to send Ether to a unique wallet address in exchange for DAO tokens on a 1–100 scale. The creation period was an unexpected success as it managed to gather 12.7M Ether (worth around $150M at the time), making it the biggest crowdfund ever. At some point, when Ether was trading at $20, the total Ether from The DAO was worth over $250 million.

In essence, the platform would allow anyone with a project to pitch their idea to the community and potentially receive funding from The DAO. Anyone with DAO tokens could vote on plans, and would then receive rewards if the projects turned a profit. With the financing in place, things were looking up.

The DAO’s Great Start Gone Wrong

However, on June 17, 2016, a hacker found a loophole in the coding that allowed him to drain funds from The DAO. In the first few hours of the attack, 3.6 million ETH were stolen, the equivalent of $70 million at the time. Once the hacker had done the damage he intended, he withdrew the attack.

In this exploit, the attacker was able to “ask” the smart contract (DAO) to give the Ether back multiple times before the smart contract could update its balance. Two main issues made this possible: the fact that when the DAO smart contract was created the coders did not take into account the possibility of a recursive call and the fact that the smart contract first sent the ETH funds and then updated the internal token balance.

It’s important to understand that this bug did not come from Ethereum itself, but from this one application that was built on Ethereum. The code written for The DAO had multiple flaws, and the recursive call exploit was one of them. Another way to look at this situation is to compare

Ethereum to the Internet and any application based on Ethereum to a website — If a site is not working, it doesn’t mean that the Internet is not working, it merely says that one website has a problem. The hacker stopped draining The DAO for unknown reasons, even though he could have continued to do so. The Ethereum community and team quickly took control of the situation and presented multiple proposals to deal with the exploit.

However, the funds were placed into an account subject to a 28 day holding period so the hacker couldn’t complete his getaway. To refund the lost money, Ethereum hard forked to send the hacked funds to an account available to the original owners. The token owners were given an exchange rate of 1 ETH to 100 DAO tokens, the same rate as the initial offering.

Unsurprisingly, the hack was the beginning of the end for the DAO. The hack itself was contested by many Ethereum users, who argued that the hard fork violated the basic tenets of blockchain technology. To make matters worse, on September 5, 2016, the cryptocurrency exchange Poloniex delisted DAO tokens, with Kraken doing the same in December 2016.

All of these issues pale in comparison to the United States Securities and Exchange Commision (SEC) ruling that was released on July 25, 2017. This report stated:

“Tokens offered and sold by a “virtual” organization known as “The DAO” were securities and therefore subject to the federal securities laws. The Report confirms that issuers of the distributed ledger or blockchain technology-based securities must register offers and sales of such securities unless a valid exemption applies. Those participating in unregistered offerings also may be liable for violations of the securities laws.”

In other words, The DAO’s offering was subject to the same regulatory principles of companies undergoing the initial public offering process. According to the SEC, The DAO violated federal securities laws, along with all of its investors.

The Ongoing Impact of The DAO’s Rise and Fall

Though The DAO project has since folded, its impact is ongoing. Current blockchain development teams continually looked to The DAO’s example for guidance — for what not to do.

First, The DAO teaches a valuable lesson about the importance of establishing secure blockchain platforms. The DAO’s hack was not due to a problem inherent on the Ethereum blockchain; it came from a coding loophole exploited by an intelligent hacker. Had the code been written correctly, the hack could have been avoided.

Second, the SEC’s ruling on The DAO has encouraged blockchain startups to come up with ways of avoiding security registration and federal regulation. One of the ways companies do this is by using the SAFT method. If tokens have legitimate utilitarian value on a blockchain platform,

they violate a component of the Howey case, and therefore cannot be listed as securities or regulated by the SEC.

Without the DAO, who knows what lessons would still need to be taught.. . Ethereum burst onto the virtual currency scene almost a year ago. It’s similar to bitcoin, but with a key difference. In addition to supporting its own digital currency, ether, it also supports smart contracts, agreements written in computer code that execute automatically when conditions are met.

Though it garnered significant attention from the start, Ethereum’s biggest moment came in April 2016, with a radical experiment called the Distributed Autonomous Organization, or the DAO. Created by German blockchain startup Slock.it, the DAO had an ambitious goal—to build a humanless venture capital firm that would allow the investors to make all the decisions through smart contracts. There would be no leaders, no authorities. Only rules coded by humans, and executed by computer protocols.

Advertisement

Launched on April 30th, it took off like a runaway train. By May 21, it had raised $150 million from roughly 11,000 investors, in what’s considered the biggest crowdfunding effort in history.

For Ethereum, the backbone of the project, it was a major vote of confidence in its nascent technology.

Then it got hacked.

On June 17th, someone started siphoning money out of the DAO. People were watching in real time as the money was stolen—like a live video feed of a bank robbery. By the end, the hacker, who has said that he was simply taking advantage of a technical loophole in the DAO, had amassed $50 million in ether, based on current exchange rates.

Advertisement

While the core developers who designed and run Ethereum didn’t really have anything to do with the DAO, they were left to deal with the mess. The seven of them, led by Vitalik Buterin, decided to hack the hacker.

They managed to stop the theft and move the funds into another smart contract where they currently sit. But that’s only a temporary stopgap: the way the code of DAO was written, there is a question of whether the original hacker can still lay claim to the funds. Fixing this would require more intervention from the core developers.

Whether to do so has created an existential question for Ethereum. One of its underlying tenets is that it’s a decentralized platform, meaning the power lies almost exclusively with all of its users. By stepping in to fix this problem, it would completely undermine that objective. This has led to a heated debate between those who want to return the funds and the “code is king” purists who say that the the power of smart contracts lies in their immutability.

The intervention that’s being weighed is called a “fork.” It’s a decentralized network’s version of a reset button. It would entail rolling back the entire Ethereum network to a previous day. Doing so would basically eliminate the DAO, and move all the money into a smart contract that can only reimburse investors.

Advertisement

The initial proposal was a soft fork. This would entail a majority of the Ethereum miners (those who verify transactions on the network) voting on the roll back. Unfortunately, a security flaw was found in the voting process, which eliminated this option.

That leaves a hard fork, where the core developers of Ethereum unilaterally make the decision to essentially create a new version of the network with different rules than the original. Then, miners, exchanges, and other major apps that are built on it need to decide if they want to a part of the new version of Ethereum or the original. Hence, the idea of a fork.

“The Hard Fork is a delicate topic and the way we see it, no decision is the right one. As this is not a decision that can be made by the foundation or any other single entity, we again turn towards the community to assess its wishes in order to provide the most appropriate protocol change,” Ethereum cofounder Jeffrey Wilcox wrote in a blog post Friday (July 15).

The community seems unanimous—according to Ethereum’s publicly available Github code, a hard fork is tentatively scheduled for July 20.

Advertisement

But, after all this turmoil, several questions remain:

What happens to the banks working on smart contracts?

Ethereum’s greatest promise lies in its ability to offer smart contracts, which are basically small programs, built on its blockchain. Financial institutions believe smart contracts offer a way to cut costs and speed up trading and settlement. Big banks like Citi and J.P. Morgan, along with clearinghouses like the Depository Trust & Clearing Corporation, have been building and testing ways to trade credit default swaps with smart contracts, for instance.

Analysts think smart contracts, if developed sufficiently, could eventually replace lawyers and judges in some cases. “Doing so in principle removes the potential for parties to have a dispute: both parties are held to whatever outcome the smart contract determines,” writes Houman Shadab, a professor at the New York Law School who specializes in the area.

Advertisement

An Ethereum hard fork, however, could be a spanner in the works. If contracts held to be inviolable can effectively be overturned by a collective decision to run new software, what guarantee do financial institutions have that their transactions and funds are secure? “I think this exposes one of the problems [facing financial institutions],” says Simon Taylor, a co-founder of financial technology consultancy 11FS, based in London.

Taylor, who headed blockchain projects at Barclays until last month, says incidents like the DAO hack and the hard fork only underscore the need for banks and other regulated institutions to build their own private blockchains. Banks can reduce the threat of a community decision being implemented without their support. “If you want results now, the answer must be to build a [virtual private network] for asset transfer,” Taylor says. “This is undoubtedly the right choice for financial institutions.”

Another bank insider thinks financial institutions will simply take a hard fork in stride. The technology is so new that banks are still in a research and development phase, so they have ample time to price in assumptions around any potential future forks, says Huy Nguyen Trieu, a well-known fintech analyst and until recently a managing director at Citi in London. “Whether you have a hard fork or soft fork, the cat is already out of the bag,” he says. “So it doesn’t change anything. Even if there was [a hard fork], whenever [banks] think of a smart contract, they will take it into account.”

What about the moral hazard of a “bailout”?

Advertisement

One of Ethereum’s core principles is that it offers a way for developers to write decentralized applications that external parties can’t alter. These applications will exist “without any possibility of downtime, censorship, fraud or third-party interference,” says Ethereum’s official documentation.

What would be the point of this? One example might be a smart contract that disbursed funds to activists in an oppressive regime. It can’t simply be shut down by a cease-and-desist order delivered to an office, or even by sending in troops to cart away servers. That’s because that particular pool of funds exists as an application on the Ethereum blockchain, which is dispersed around the world on whatever servers run its code.

This property of Ethereum is known as censorship resistance. But if a hard fork is implemented to reverse a smart contract gone wrong, doesn’t this violate the principle of censorship resistance? “If you take the direction of restoring value to people who lost value, you break the idea of smart contracts,” says Vinay Gupta, a London-based strategist at Consensys, one of the most well known development firms working on Ethereum. ”Maybe we can justify this as a one-off, and it won’t happen again. But maybe it opens the door to a never-ending string of complaints from people who lost 25 cents and want it back.”

The decision to hard-fork the protocol in order to return the hacked funds is a sort of moral hazard for the cryptocurrency world. Just as central bankers were confronted with having to bail out failing banks in 2008, the miners, exchanges, and companies in the Ethereum economy now must face the prospect of a systemic intervention to right a wrong. The irony isn’t lost on Gupta. ”It turns out we have a lot in common with central banks,” he says. “Maybe not at the technical or legal level, but at a political level, people in our community expect us to be able to make things better for them.”

Advertisement

Even a true believer in Ethereum like Gupta is aware that a hard fork could be a serious violation of the principles that underlie the protocol. He stops short of saying a hard fork is a bad idea, but notes that “there are convincing arguments” on both sides. The decision to fork, or not, is a bit like voting for Brexit, he says. “ There’s no way in the UK right now that you can make any kind of comfortable prediction of our economy, because it’s changed, but we don’t know what the new rules will be,” he says. “It’s that sort of prolonged uncertainty.”

And, like Brexit, the Ethereum economy will be gambling with its future if it collectively agrees to pursue a fork. “We just have to roll the dice and see what happens,” Gupta says.

What happens to the price of Ether?

Ether’s price has tumbled from a high of about $15 as the DAO gained momentum to a current price of about $10. That’s instructive, because despite the uncertainty surrounding a potentially major change to the Ethereum codebase, the price has remained relatively stable.

Advertisement

While a decline of 33% might seem like a steep drop, it’s important to remember that this is roughly what ether was trading at in the months before the DAO launched. The DAO triggered a sharp spike in the price of ether as people bought the currency to participate in the experiment. So a drop back to the $10 level, even with a fork looming, is a vote of confidence from the market. At the start of the year, ether was trading at under a dollar.

That suggests the ether market has priced in the hard fork decision. Joe Lee, a co-founder of bitcoin derivatives platform Magnr in London, expects a successful hard fork decision to therefore boost the price of ether. ”I see this as validation that the community can build a very powerful system like Ethereum in the right way,” he says.

Lee has a price target of $15 for ether before the year is up, returning it to its pre-DAO hack heights.

Despite the drama over the previous weeks around the DAO hack, counter-hack, and forking proposals, the outlook for Ethereum is, implausibly, bright. Observers point to the way Ethereum developers have rapidly developed alternatives to solve the flood of technical and ethical problems revealed by the hack.

Advertisement

Emin Gün Sirer, the Cornell professor who has perhaps contributed the most research in the aftermath of the DAO hack, contrasts the way the Ethereum world has adapted to his discoveries of technical flaws with the DAO and its subsequent fixes. “The Ethereum community has been amazingly science-driven, open and forthright. The civilness of their response should be a shining example to other communities,” he wrote.

Correction: An earlier version of this post said Slock.it was based in Sweden.. Security considerations override all other considerations in software in general and in blockchain specifically. If security fails, nothing else matters. Blockchain proves decentralized, trustless transactions work, but many blockchain security vulnerabilities remain nonetheless.

Security exploits exist at the design and architectural level, at the coding stage, and in the operational phase. And in case you were wondering, yes, the blockchain can be hacked.

Blockchain Security Vulnerabilities – From Here to Eternity

Diamonds are forever, and smart contracts live for as long as the blockchain they are deployed on continues to be used. Consequently, all bugs and blockchain security vulnerabilities also live as long as the contract does.

Typically, each blockchain provides its own programming language to implement smart contracts. Let’s take a closer look.

Smart Contract Languages

Blockchain environments include their own languages for developing smart contracts.

The Ethereum platform, for example, includes the Solidity language to write smart contracts. The creators designed Solidity to be a Turing complete language.

A Turing complete language essentially allows the programmer to implement anything the underlying system is capable of. Consequently, this gives programmers abilities like implementing loops in the code, which can potentially cause blockchain security vulnerabilities.

Turing Completeness

Turing complete languages contain complexity by nature, and complexity invites bugs and vulnerabilities.

The Bitcoin network also has a programming language which it calls Script. Script is purposely not Turing complete to enhance security.

The fewer options that are given to a programmer, the less likely for blockchain security vulnerabilities to enter the system.

To minimize the risk of releasing faulty code into the wild, programmers must understand common pitfalls and anti-patterns inherent in smart contract programming. (Anti-patterns represent bad programming practices).

The DAO Hack: The Reentrancy Problem

The reentrancy problem probably ranks highest among blockchain security vulnerabilities programmers coded into smart contracts. Reentrancy drains an account through multiple expenditures for the same transaction. The use case of processing refunds lends itself to this exploit, but this flaw affects any kind of transaction if not addressed at the design and coding stage.

In one of the most infamous cryptocurrency attacks to date, hackers of the DAO exploited reentrancy. No organizational leader dictated how to run the DAO (or Decentralized Autonomous Organization), and the DAO proposed to empower users with the ability to vote on projects to invest in.

It raised over $150 million in funding in its first month. On June 17, 2016, hackers drained $50 million from the organization through the reentrancy flaw. The hard fork from Ethereum Classic (ETC) to Ethereum (ETH) resulted in an effort to resolve the problems this hack created.

Anti-Pattern Vulnerable to Reentrancy

A vulnerable reentrant logic for code looks like this:

function to process a payment () {

(1) check the validity of the transaction, the recipient, and the account balance;

(2) process the transaction;

(3) update the state of the system to show the transaction has been processed;

}

At first glance, the logic looks correct and complete, but the flaw resides in the order of doing step 2 before step 3.

While the first call to the function continues processing step 2, another call for the same transaction can enter the function. Since state information remains in its initial state and not yet processed in step 3, the second call checks out as a valid transaction to process.

Consequently, the system spends currency for the same obligation a second time. Hackers rush multiple transactions to the function before the state gets set properly.

Cure for Reentrancy

This change to the algorithm corrects the above problem:

function to process a payment () {

(1) check the validity of the transaction, the recipient, and the account balance;

(2) update the state of the system to show the transaction has been processed;

(3) process the transaction;

}

The code must account for all necessary exception handling, and it must account for all logical dependencies as well.

Overflow

Overflow is another common security flaw programmers need to be aware of.

Some programming languages provide strong typing, and others provide weak typing. Strongly typed languages refuse to allow programmers to assign string data to a numeric variable, for example, and weakly typed languages allow such actions.

Strongly typed languages enforce range restrictions. If an array is ten elements, programmers cannot attempt to access the eleventh element. Weakly typed languages allow such behavior, but crashes result. If the maximum allowable value a variable holds is 99, and you assign it a value of 100, watch it crash when you run it!

Consequently, overflow is an exploit that hackers use. If a hacker feeds a parameter to a smart contract that is out of the range the code can process, a crash results. Such a crash fuels multiple exploits. The crash could trigger a denial of service attack (DDoS attack), and vital information about the internals of the system sometimes reveal themselves in error messages.

In web applications, hackers often fill memory with their own malicious code, so when the program crashes and goes to a random spot in memory, the malicious code executes.

Weakly typed languages provide power and dynamic flexibility, but they also require more rigorous design and testing to be hardened against attacks.

The Many-Headed Hydra

A multitude of security issues plagues the software world. As new technology emerges, new threats appear. Besides the exploits mentioned above, these notable flaws represent just a few of the many other blockchain security vulnerabilities.

Bad cryptography creates many headaches. Cryptography ensures privacy, and when privacy breaks, everything breaks. The IOTA team made the mistake of writing their own cryptographic library from scratch in the initial version of their product. The problem inherent in rolling your own cryptography is that all complex software contains bugs, so you are guaranteed to have buggy cryptography.

Established cryptographic libraries survive vetting by academics and prove reliable over time through life in the wild.

In the world of wallets, random number generation must be truly random. Particularly in the early days of cryptocurrency, some wallets failed this requirement.

Cryptocurrency addresses require addresses that must be unique. Uniqueness comes from a random number generator, and the random number generator needs a seed to begin the process. If the seed fails to be truly random, the system fails.

One result of bad randomness means the same address gets created multiple times. Picture the scenario where a wallet assigns address X to person A, and then sometime later assigns address X to person B. When a payment goes to address X it only goes to one person. Which person gets the money?

Another problem with bad randomness arises when a hacker figures out the algorithm used to create the seed. The hacker regenerates the seed for himself and owns the system.

[thrive_leads id=’5219′]

The Road Goes On Forever and the Party Never Ends

Security is a never-ending battle, and even if programmers, architects, and testers remove all vulnerabilities from the code, operational vulnerabilities remain.

In a Proof of Work environment, if bad actors control 51% of the network, integrity is destroyed. Game theory provides mitigation for this attack. A new cryptocurrency with a small network exposes most risk to this attack. But a 51% attack destroys the value of the currency, so attackers just hurt themselves.

Blockchains live on the internet and share all the same exposure to hackers as the internet. For instance, suppose you buy coins from an exchange on a website. Injection attacks, cross-site scripting, phishing attacks and all the other traditional website hacks prevail.

Final Thoughts

Just as programmers guard against bugs, programmers must factor security into their development. Some tools exist to aid programmers in the task, but programmers must first understand their own vulnerabilities to guard against them.

The Decentralized Application Security Project (DASP) aspires to be a repository of information and resources on blockchain security. They model themselves somewhat on the Open Web Application Security Project (OWASP). The annual OWASP Top 10 definitely lists the primary web application vulnerabilities currently in existence. The DASP Top 10 hopes to provide the equivalent resource for blockchain.

Not all attacks are known beforehand. A zero-day exploit defines an exploit hackers know about before anyone else does. So programmers must think like attackers when designing and implementing software. If you don’t find the vulnerabilities in your code, expect a hacker looking for profit to find them.. by Haseeb Qureshi

A hacker stole $31M of Ether — how it happened, and what it means for Ethereum

Yesterday, a hacker pulled off the second biggest heist in the history of digital currencies.

Around 12:00 PST, an unknown attacker exploited a critical flaw in the Parity multi-signature wallet on the Ethereum network, draining three massive wallets of over $31,000,000 worth of Ether in a matter of minutes. Given a couple more hours, the hacker could’ve made off with over $180,000,000 from vulnerable wallets.

But someone stopped them.

Having sounded the alarm bells, a group of benevolent white-hat hackers from the Ethereum community rapidly organized. They analyzed the attack and realized that there was no way to reverse the thefts, yet many more wallets were vulnerable. Time was of the essence, so they saw only one available option: hack the remaining wallets before the attacker did.

By exploiting the same vulnerability, the white-hats hacked all of the remaining at-risk wallets and drained their accounts, effectively preventing the attacker from reaching any of the remaining $150,000,000.

Yes, you read that right.

To prevent the hacker from robbing any more banks, the white-hats wrote software to rob all of the remaining banks in the world. Once the money was safely stolen, they began the process of returning the funds to their respective account holders. The people who had their money saved by this heroic feat are now in the process of retrieving their funds.

It’s an extraordinary story, and it has significant implications for the world of cryptocurrencies.

It’s important to understand that this exploit was not a vulnerability in Ethereum or in Parity itself. Rather, it was a vulnerability in the default smart contract code that the Parity client gives the user for deploying multi-signature wallets.

This is all pretty complicated, so to make the details of this clear for everyone, this post is broken into three parts:

What exactly happened? An explanation of Ethereum, smart contracts, and multi-signature wallets. How did they do it? A technical explanation of the attack (specifically for programmers). What now? The attack’s implications about the future and security of smart contracts.

If you are familiar with Ethereum and the crypto world, you can skip to the second section.

1. What exactly happened?

There are three building blocks to this story: Ethereum, smart contracts, and digital wallets.

Ethereum is a digital currency invented in 2013 — a full 4 years after the release of Bitcoin. It has since grown to be the second largest digital currency in the world by market cap — $20 billion, compared to Bitcoin’s $40 billion.

Like all cryptocurrencies, Ethereum is a descendant of the Bitcoin protocol, and improves on Bitcoin’s design. But don’t be fooled: though it is a digital currency like Bitcoin, Ethereum is much more powerful.

While Bitcoin uses its blockchain to implement a ledger of monetary transactions, Ethereum uses its blockchain to record state transitions in a gigantic distributed computer. Ethereum’s corresponding digital currency, ether, is essentially a side effect of powering this massive computer.

To put it another way, Ethereum is literally a computer that spans the entire world. Anyone who runs the Ethereum software on their computer is participating in the operations of this world-computer, the Ethereum Virtual Machine (EVM). Because the EVM was designed to be Turing-complete (ignoring gas limits), it can do almost anything that can be expressed in a computer program.

Let me be emphatic: this is crazy stuff. The crypto world is ebullient about the potential of Ethereum, which has seen its value skyrocket in the last 6 months.

The developer community has rallied behind it, and there’s a lot of excitement about what can be built on top of the EVM — and this brings us to smart contracts.

Smart contracts are simply computer programs that run on the EVM. In many ways, they are like normal contracts, except they don’t need lawyers or judges to interpret them. Instead, they are compiled to bytecode and interpreted unambiguously by the EVM. With these programs, you can (among other things) programmatically transfer digital currency based solely on the rules of the contract code.

Of course, there are things normal contracts do that smart contracts can’t — smart contracts can’t easily interact with things that aren’t on the blockchain. But smart contracts can also do things that normal contracts can’t, such as enforce a set of rules entirely through unbreakable cryptography.

This leads us to the notion of wallets. In the world of digital currencies, wallets are how you store your assets. You gain access to your wallet using essentially a secret password, also known as your private key (simplified a bit).

There are many different types of wallets that confer different security properties, such as withdrawal limits. One of the most popular types is the multi-signature wallet.

In a multi-signature wallet, there are several private keys that can unlock the wallet, but just one key is not enough to unlock it. If your multi-signature wallet has 3 keys, for example, you can specify that at least 2 of the 3 keys must be provided to successfully unlock it.

This means that if you, your father, and your mother are each signatories on this wallet, even if a criminal hacked your mother and stole her private key, they could still not access your funds. This leads to much stronger security guarantees, so multi-sigs are a standard in wallet security.

This is the type of wallet the hacker attacked.

So what went wrong? Did they break the private keys? Did they use a quantum computer, or some kind of cutting-edge factoring algorithm?

Nope, all the cryptography was sound. The exploit was almost laughably simple: they found a programmer-introduced bug in the code that let them re-initialize the wallet, almost like restoring it to factory settings. Once they did that, they were free to set themselves as the new owners, and then walk out with everything.

2. How did this happen?

What follows is a technical explanation of exactly what happened. If you’re not a developer, feel free to skip to the next section, since this is going to be programming-heavy.

Ethereum has a fairly unique programming model. On Ethereum, you write code by publishing contracts (which you can think of as objects), and transactions are executed by calling methods on these objects to mutate their state.

In order to run code on Ethereum, you need to first deploy the contract (the deployment is itself a transaction), which costs a small amount of Ether. You then need to call methods on the contract to interact with it, which costs more Ether. As you can imagine, this incentivizes a programmer to optimize their code, both to minimize transactions and minimize computation costs.

One way to reduce costs is to use libraries. By making your contract call out to a shared library that was deployed at a previous time, you don’t have to re-deploy any shared code. In Ethereum, keeping your code DRY will directly save you money.

The default multi-sig wallet in Parity did exactly this. It held a reference to a shared external library which contained wallet initialization logic. This shared library is referenced by the public key of the library contract.

// FIELDSaddress constant _walletLibrary = 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3;

The library is called in several places, via an EVM instruction called DELEGATECALL , which does the following: for whatever method that calls DELEGATECALL , it will call the same method on the contract you're delegating to, but using the context of the current contract. It's essentially like a super call, except without the inheritance part. (The equivalent in JavaScript would be OtherClass.functionName.apply(this, args) .)

Here’s an example of this in their multi-sig wallet: the isOwner method just delegates to the shared wallet library's isOwner method, using the current contract's state:

function isOwner(address _addr) constant returns (bool) { return _walletLibrary.delegatecall(msg.data);}

This is all innocent enough. The multi-sig wallet itself contained all of the right permission checks, and they were sure to rigorously enforce authorization on all sensitive actions related to the wallet’s state.

But they made one critical mistake.

Solidity allows you to define a “fallback method.” This is the method that gets called when there’s no method that matches a given method name. You define it by not giving it a name:

function() { // do stuff here for all unknown methods}

The Parity team decided to let any unknown method that sent Ether to the contract just default to depositing the sent Ether.

function() payable { // payable is just a keyword that means this method can receive/pay Ether

if (msg.value > 0) { // just being sent some cash? Deposit(msg.sender, msg.value); } else { throw; }}

But they took it a step further, and herein was their critical mistake. Below is the actual code that was attacked.

function() payable { // just being sent some cash? if (msg.value > 0) Deposit(msg.sender, msg.value); else if (msg.data.length > 0) _walletLibrary.delegatecall(msg.data);}

Basically:

If the method name is not defined on this contract…

And there’s no ether being sent in the transaction…

And there is some data in the message payload…

Then it will call the exact same method if it’s defined in _walletLibrary , but in the context of this contract.

Using this, the attacker called a method called initWallet() , which was not defined on the multisig contract but was defined in the shared wallet library:

function initWallet(address[] _owners, uint _required, uint _daylimit) { initDaylimit(_daylimit); initMultiowned(_owners, _required);}

Which calls the initMultiowned method...

function initMultiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required;}

Do you see what just happened there? The attacker essentially reinitialized the contract by delegating through the library method, overwriting the owners on the original contract. They and whatever array of owners they supply as arguments will be the new owners.

Given that they now control the entire wallet, they can trivially extract the remainder of the balance. And that’s precisely what they did.

The initWallet: https://etherscan.io/tx/0x707aabc2f24d756480330b75fb4890ef6b8a26ce0554ec80e3d8ab105e63db07

The transfer:

https://etherscan.io/tx/0x9654a93939e98ce84f09038b9855b099da38863b3c2e0e04fd59a540de1cb1e5

So what was ultimately the vulnerability? You could argue there were two. First, the initWallet and initMultiowned in the wallet library were not marked as internal (this is like a private method, which would prevent this delegated call), and those methods did not check that the wallet wasn't already initialized. Either check would've made this hack impossible.

The second vulnerability was the raw delegateCall . You can think of this as equivalent to a raw eval statement, running on a user-supplied string. In an attempt to be succinct, this contract used metaprogramming to proxy potential method calls to an underlying library. The safer approach here would be to whitelist specific methods that the user is allowed to call.

The trouble, of course, is that this is more expensive in gas costs (since it has to evaluate more conditionals). But when it comes to security, we probably have to get over this concern when writing smart contracts that move massive amounts of money.

So that was the attack.

It was a clever catch, but once you point it out, it seems almost elementary. The attacker then jumped on this vulnerability for three of the largest wallets they could find — but judging from the transaction times, they were doing this entirely manually.

The white-hat group was doing this at scale using scripts, and that’s why they were able to beat the attacker to the punch. Given this, it’s unlikely that the attacker was very sophisticated in how they planned their attack.

You might ask the question though — why don’t they just roll back this hack, like they did with the DAO hack?

Unfortunately that’s not really possible. The DAO hack was unique in that when the attacker drained the DAO into a child DAO, the funds were frozen for many days inside a smart contract before they could be released to the attacker.

This prevented any of the stolen funds from going into circulation, so the stolen Ether was effectively siloed. This gave the Ethereum community plenty of time to conduct a public quorum about how to deal with the attack.

In this attack, the attacker immediately stole the funds and could start spending them. A hard fork would be impractical–what do you do about all of the transactions that occur downstream? What about the people who innocently traded assets with the attacker? Once the ether they’ve stolen gets laundered and enters general circulation, it’s like counterfeit bills circulating in the economy — it’s easy to stop when it’s all in one briefcase, but once everyone’s potentially holding a counterfeit bill, you can’t really turn back the clock anymore.

So the transaction won’t get reversed. The $31M loss stands. It’s a costly, but necessary lesson.

So what should we take away from this?

3. What does this attack mean for Ethereum?

There are several important takeaways here.

First, remember, this was not a flaw in Ethereum or in smart contracts in general. Rather, it was a developer error in a particular contract.

So who were the crackpot developers who wrote this? They should’ve known better, right?

The developers here were a cross-collaboration between the Ethereum foundation (literally the creators of Ethereum), the Parity core team, and members of the open-source community. It underwent extensive peer review. This is basically the highest standard of programming that exists in the Ethereum ecosystem.

These developers were human. They made a mistake. And so did the reviewers who audited this code.

I’ve read some comments on Reddit and HackerNews along the lines of: “What an obvious mistake! How was it even possible they missed this?” (Ignoring that the “obvious” vulnerability was introduced in January and only now discovered.)

When I see responses like this, I know the people commenting are not professional developers. For a serious developer, the reaction is instead: damn, that was a dumb mistake. I’m glad I wasn’t the one who made it.

Mistakes of this sort are routinely made in programming. All programs carry the risk of developer error. We have to throw off the mindset of “if they were just more careful, this wouldn’t have happened.” At a certain scale, carefulness is not enough.

As programs scale to non-trivial complexity, you have to start taking it as a given that programs are probably not correct. No amount of human diligence or testing is sufficient to prevent all possible bugs. Even organizations like Google or NASA make programming mistakes, despite the extreme rigor they apply to their most critical code.

We would do well to take a page from site reliability practices at companies like Google and Airbnb. Whenever there’s a production bug or outage, they do a postmortem analysis and distribute it within the company. In these postmortems, there is always a principle of never blaming individuals.

Blaming mistakes on individuals is pointless, because all programmers, no matter how experienced, have a nonzero likelihood of making a mistake. Instead, the purpose of a postmortem is to identify what in the process allowed that mistake to get deployed.

The problem was not that the developer forgot to add internal to the wallet library, or that they did a raw delegateCall without checking what method was being called.

The problem is that their programming toolchain allowed them to make these mistakes.

As the smart contract ecosystem evolves, it has to evolve in the direction of making these mistakes harder, and that means making contracts secure by default.

This leads me to my next point.

Strength is a weakness when it comes to programming languages. The stronger and more expressive a programming language is, the more complex its code becomes. Solidity is a very complex language, modeled to resemble Java.

Complexity is the enemy of security. Complex programs are more difficult to reason about and harder to identify edge cases for. I think that languages like Viper (maintained by Vitalik Buterin) are a promising step in this direction. Viper includes by default basic security mechanisms, such as bounded looping constructs, no integer overflows, and prevents other basic bugs that developers shouldn’t have to reason about.

The less the language lets you do, the easier it is to analyze and prove properties of a contract. Security is hard because the only way to prove a positive statement like “this contract is secure” is to disprove every possible attack vector: “this contract cannot be re-initialized,” “its funds cannot be accessed except by the owners,” etc. The fewer possible attack vectors you have to consider, the easier it is to develop a secure contract.

A simpler programming model also allows things like formal verification and automatic test generation. These are areas under active research, but just as smart contracts have incorporated cutting-edge cryptography, they also should start incorporating the leading edge of programming language design.

There is a bigger lesson here too.

Most of the programmers who are getting into this space, myself included, come from a web development background, and the blockchain toolchain is designed to be familiar for web developers. Solidity has achieved tremendous adoption in the developer community because of its familiarity to other forms of programming. In a way, this may end up being its downfall.

The problem is, blockchain programming is fundamentally different from web development.

Let me explain.

Before the age of the client-server web model, most programming was done for packaged consumer software or on embedded systems. This was before the day of automatic software updates. In these programs, a shipped product was final — you released one form of your software every 6 months, and if there was a bug, that bug would have to stand until the next release. Because of this longer development cycle, all software releases were rigorously tested under all conceivable circumstances.

Web development is far more forgiving. When you push bad code to a web server, it’s not a big deal if there’s a critical mistake — you can just roll back the code, or roll forward with a fix, and all is well because you control the server. Or if the worst happens and there’s an active breach or a data leak, you can always stop the bleeding by shutting off your servers and disconnecting yourself from the network.

These two development models are fundamentally different. It’s only out of something like web development that you can get the motto “move fast and break things.”

Most programmers today are trained on the web development model. Unfortunately, the blockchain security model is more akin to the older model.

In blockchain, code is intrinsically unrevertible. Once you deploy a bad smart contract, anyone is free to attack it as long and hard as they can, and there’s no way to take it back if they get to it first. Unless you build intelligent security mechanisms into your contracts, if there’s a bug or successful attack, there’s no way to shut off your servers and fix the mistake. Being on Ethereum by definition means everyone owns your server.

A common saying in cybersecurity is “attack is always easier than defense.” Blockchain sharply multiplies this imbalance. It’s far easier to attack because you have access to the code of every contract, know how much money is in it, and can take as long as you want to try to attack it. And once your attack is successful, you can potentially steal all of the money in the contract.

Imagine that you were deploying software for vending machines. But instead of a bug allowing you to simply steal candy from one machine, the bug allowed you to simultaneously steal candy from every machine in the world that employed this software. Yeah, that’s how blockchain works.

In the case of a successful attack, defense is extremely difficult. The white-hats in the Parity hack demonstrated how limited their defense options were — there was no way to secure or dismantle the contracts, or even to hack back the stolen money; all they could do was hack the remaining vulnerable contracts before the attacker did.

This might seem to spell a dark future.

But I don’t think this is a death knell for blockchain programming. Rather, it confirms what everyone already knows: this ecosystem is young and immature. It’s going to take a lot of work to develop the training and discipline to treat smart contracts the way that banks treat their ATM software. But we’re going to have to get there for blockchain to be successful in the long run.

This means not just programmers maturing and getting more training. It also means developing tools and languages that make all of this easier, and give us rigorous guarantees about our code.

It’s still early. Ethereum is a work in progress, and it’s changing rapidly. You should not treat Ethereum as a bank or as a replacement for financial infrastructure. And certainly you should not store any money in a hot wallet that you’re not comfortable losing.

But despite all that, I still think Ethereum is going to win in the long run. And here’s why: the developer community in Ethereum is what makes it so powerful.

Ethereum will not live or die because of the money in it. It will live or die based on the developers who are fighting for it.

The league of white-hats who came together and defended the vulnerable wallets didn’t do it for money. They did it because they believe in this ecosystem. They want Ethereum to thrive. They want to see their vision of the future come true. And after all the speculation and the profiteering, it’s ultimately these people who are going to usher the community into its future. They are fundamentally why Ethereum will win in the long run—or if they abandon Ethereum, their abandonment will be why it loses.

This attack is important. It will shake people up. It will force the community to take a long, hard look at security best practices. It will force developers to treat smart contract programming with far more rigor than they currently do.

But this attack hasn’t shaken the strength of the builders who are working on this stuff. So in that sense it’s a temporary setback.

In the end, attacks like this are good for the community to grow up. They call you to your senses and force you to keep your eyes open. It hurts, and the press will likely make a mess of the story. But every wound makes the community stronger, and gets us closer to really deeply understanding the technology of blockchain — both its dangers, and its amazing potential.

P.S. If you’re a dev and you want to learn more about smart contract security, this is a really good resource.

Errata: This article originally said that Gavin Wood was the developer of the contract, which is incorrect. Gavin is the founder of Parity and pushed the fix to the contract, but was not the original developer. It also originally claimed that $77M additional funds were vulnerable, but this doesn’t count all of the ERC20 (ICO) tokens that were vulnerable. The total amount is actually $150,000,000+ if you include all ERC20 tokens. As of the time of writing this (July 21st 4PM EST), the total value of the assets saved by the white-hats was $179,704,659.. We have done our best to curate and clarify The DAO hack developments. This page will be updated to reflect new developments. Do not hesitate to flag inconsistencies and suggest updates.

[Lire cette FAQ en français]

UPDATE 30 June: The envisioned temporary solution - a soft fork (see Q8 below), - has been discarded. The rationale is security: shortly after the technical implementation of the soft fork was proposed, a harmful attack vector was identified. This is a simple explanation of what it could cause to the network:

So, put simply: the soft-fork would allow an attacker to send many transactions to a mining node which the node would have to execute in order to detect that a call is being made to the contract. This would cost the attacker nothing and would slow down and potentially stop transaction mining while the soft fork is in place. A well-organised, well-financed attacker could probably cause substantial disruption to the network and reduce the fees you receive using this attack.

Although the vector was not used to attack the network so far, it bears the potential to significantly damage the network. Consequently, the soft fork as proposed a few days ago (see Q8. below) will not happen. The current options on the table are unclear, but discussions within the community start to show a growing acceptance of a hard fork (see Q10 below for what it is).

On 17 June 2016, an unknown individual or group exploited The DAO. The latter is the first and biggest crowdfunded and crowdequity-like fund based entirely on the Ethereum blockchain. If you would like to get an insight about The DAO, please read this explanation.

The attacker(s) exploited a software vulnerability and started draining ether from the primary address where it was stored. This attack resulted in the draining off of some 3.6 million ether from The DAO. This amounts to around a third of The DAO ether.

The drained ether was directed to what is referred to as a 'child DAO'. This 'child DAO' is an address where the sole curator is the attacker or group of attackers. Consequently, around a third of the total DAO fund got trapped in this 'child DAO'. Technicalities aside, the diverted assets cannot be withdrawn by the attacker for a total of 27 days following the creation of the child DAO.

In the following Q&A, we have done our best to untangle the complexities of the attack and explain their implications. As this is an evolving situation, we will certainly update our explainer to reflect new developments.

"Q1. So, you know who hacked The DAO?"

No, we do not. Outside of the perpetrator(s), nobody from the Ethereum community seems to know who the attacker(s) is(are). What is known at this time is that:

(a) the attacker(s) needed seven days to initiate the split;

(b) the two key contracts which held the tokens and allowed the recursive split were created two days before the attack; and

(c) the attacker(s) is(are) careful and used ether emanating from an account at ShapeShift.

"Q2. Was the hack, attack (as in a ‘bad action’)?"

The hack of The DAO is caused by a software vulnerability. Some might argue that the contract underlying The DAO allowed the exploit to happen and, therefore, the hack perpetrator ran a valid smart contract with a “draining feature”. There are, however, clear indications that the hack is ill-intentioned from its inception:

1/ The hacker considers the 3.6 million ether they drained from The DAO to be a reward for the exploit. This is contrary to The DAO’s mission, which is to fund projects.

2/ There is no way of independently validating that the “open letter” circulated a few days ago is indeed authored by the hack perpetrator. That text is the only public expression from the hacker or group of hackers, and its stance and tonality are clearly adversarial. The “open letter” contains no mention of a constructive approach, but includes an explicit formulation that the perpetrator rationally caused harm:

“I have carefully examined the code of The DAO and decided to participate after finding the feature where splitting is rewarded with additional ether.”

This sentence, as well as the whole letter, are a well-thought and calculated message. As aforementioned and clearly seen from this “open letter”, for the hacker, the end point of the operation was to keep the diverted funds, rather than fund companies.

3/ The perpetrator(s) offered to distribute funds (both bitcoin and ether) to miners who refuse to follow the proposed fork. Such a move is clearly aimed to damage trust and divide the Ethereum community, no matter whether said miners hold or not DAO tokens.

All things combined and all grains of salt added, it seems clear that the hacker's intent was to harm The DAO and the Ethereum community. The perpetrator’s ill-intentioned actions put a black mark of confidence against the field of crypto technologies. For those reasons, we qualify the hack as an attack, and the hack perpetrator(s) as attacker(s).

"Q3. OK, it sounds like some dude was nasty. The attack is made, ether has been diverted by a rogue actor. But then what do we do to fetch back the assets?"

That is the million-dollar question (no pun intended). Three main options exist; here, we do not go into the technical details, rather highlight the most significant outcomes of each option:

1/ Do nothing and leave it as is;

2/ Destroy the 'child DAO' to prevent the attacker(s) to get hold of the drained ether (also known as a soft fork; impacts the behaviour of the miners);

3/ Overwrite the Ethereum blockchain to erase the exploit and restore the situation as it were before the hack (also known as a hard fork).

Understandably, option #1 is the least desirable: the community, DAO token holders or not, is unwilling to leave the situation rot. Doing nothing would automatically result in several million ether seamlessly reach an unknown person or entity.

Option #2 , the soft fork, is another way of dealing with the issue. Technicalities aside, such an operation is a one-time fix and would prevent the attacker(s) to withdraw the diverted ethers from the 'child DAO'. You may have guessed it: the soft fork would destroy the stolen ethers rather than return them to The DAO, and the thief would be gone. On 27 June, a soft fork implementation started being integrated (see Q6. below for details).

The 3rd option , referred to as the hard fork, is still highly contested. Indeed, this possibility would restore all the ether but would also alter the Ethereum blockchain significantly.

A quite obvious suggestion would be to drain back the child DAO to reset the ether where it originally belongs. As aforementioned, the attacker(s) being the sole curator, this is impossible. However, an alternative was proposed by Lefteris Karapetsas (CTO at Slock.it), involving a series of soft forks. This discussion explains the approach in greater detail.

Additional, alternative, options are on the table as well.

"Q4. OK, all that is a bit technical. I bought The DAO tokens - are those outside of the child DAO safe?"

Unfortunately not. The attacker(s) approach has the potential to drain all ether out of The DAO. The initial attack was interrupted after Ethereum’s co-founder, Vitalik Buterin, publicly outlined the possible fork options. Since the attacker(s) identity(ies) is(are) unknown, it is unclear what the rationale behind the interruption was.

There has been much activity on that side, so it is heavy to describe all of the details here. You may want to have a look at this overview for leads as it provides a synthetic scheme of the operations and identifies the accounts involved.

"Q5. I heard about a white hat attack against The DAO that was supposed to secure the drained ether. Was that successful?"

Yes and no. A group referred to as ‘Robin Hood’ indeed started off a white hat draining of The DAO. As the latter still contains ⅔ of the ether collected during the ‘fundraiser’, the rationale behind ‘Robin Hood’ was to secure the assets in a brand new, ‘white’ child DAO to prevent another major malevolent attack against the original DAO. The issue is that the attacker(s) has taken a stake in the rescue operation, enabling them to counter-attack the ‘Robin Hood’ led manoeuvre... Moreover, in this case, similarly to the initial rogue attack, the ether will not be available before a 27-day period expires.



The proportions expressed above reflect the following ether amounts: The DAO has collected 12 million ether; 3.6 million of those are diverted and contained in the rogue child DAO. Another 7.2 million ether are currently secured in the ‘Robin Hood’ DAO. The remaining 1.2 million are allocated in both The DAO and other, smaller split DAOs.

"Q6. How are the exit options looking like at the moment? I gather this is a complicated question, but what could we envision as a way to contain the crisis?"

A positive note in this situation is that we have some time ahead of us. As aforementioned, the malicious child DAOs do not allow for ether to be withdrawn for 27 days after creation, which, at the time of writing, provides us with two and something weeks to elaborate a viable exit strategy.

A week after the attack, the following options were on the table:

1/ Do nothing: in this case, the ‘Robin Hood’ child DAO will release the ether it holds, the illegitimate splits would carry on with their ether. Additionally, the whole debacle would have serious repercussions on Ethereum as a community and as a network, and on ether as a cryptocurrency.

2/ A soft fork: It is important to highlight that the soft fork is a temporary solution that would insulate the ether from all DAOs from further interactions. Following the proposal in the wake of the malicious attack, such an operation would freeze all assets, regardless of which DAO they are in, and isolate them from anyone. This would freeze the total ether invested in The DAO ad vitam aeternam (which is significant as The DAO englobes nearly 16 percent of all ether on Earth).

3/ Another soft fork: it would limit all interactions with The DAO and the various child DAOs, except the ones whose curators are identified ‘white hats’. After a few months of cat-and-mouse, the ether from the ‘Robin Hood’-operated and the malevolent child DAOs would be fetched back and retributed to their initial investors. This operation could intervene as a follow-up of Option #2, thus preventing the ether to remain frozen forever.

4/ A hard fork: either without a prior soft fork or as a soft fork follow up. The outcome, as discussed in the wake of the malicious attack, would result in reverting the Ethereum blockchain back to a ‘sane’ block from before the attack, thus restoring all ether invested in The DAO to its initial owners with no monetary loss.

"Q7. So what is needed for the soft fork to happen?"

The activation requires a coordinated effort from 51 percent of the miners (to prevent the probability that miners from losing their ether). The coordination will outcome a block in the future which will be used to switch over to the new version of the blockchain.

On 22 June, a voting on whether to implement a soft fork started on Ethpool and Ethermine. Dwarfpool, the largest ether mine, has already joined in although a little proportion of its hash power has taken a stance. The voting will end “a few days before the freeze period of the child DAO.”

"Q8. What did the vote on the soft fork say then?"

A large majority of miners have ‘voted’ in favour of a soft fork that has features from options #2 and #3 as described above (see Q6. above). In an update on the operation, the Ethereum Foundation said:

If the soft-fork passes, it will block all DAOs from releasing funds, not just the ones the community considers attacked. This is understandably undesired for all legitimately split DAOs. As such – if the community votes to enact the soft-fork – we propose a follow up patch to the soft-fork that will whitelist all DAOs split according to the intent upheld by the enacted soft-fork.

According to Etherchain.org, many mining pools have accepted the change underlying the proposed soft fork. Should that trend continue, the soft fork is expected to take hold on 30 June.

"Q9. So what if ever the soft fork failed?"

The outlook is messy. Vulnerability exploits are likely, by ‘black’ and ‘white’ hat hackers alike. Some mitigation tactics can be imagined to prevent significant amounts of tokens to be immediately diverted. However, that situation would be rather hopeless as it would amount to endless splitting, with potential ill-intentioned interventions (e.g., spamming the network, bribing miners to impact specific transactions, etc.). In this case, the perspective is gloom for The DAO tokens, which would lose any value. Preventing this apocalyptic scenario is a clear argument in favour of a soft fork.

"Q10. What about the hard fork - what is needed for it to happen?"

Since a hard fork would significantly impact the very structure of the Ethereum blockchain, activating that option will indeed require a well-elaborated consensus on how, what, when, etc. For a hard fork to occur, the key players of the Ethereum community (the Ethereum Foundation, the EthCore developers, etc.) are more important than the miners.

Naturally, all changes are possible, even creating new ether or destroying existing legit ether. It is unlikely that the community agrees with all the whimsical changes a hard fork bears the potential to introduce. A hard fork might be a way to retrieve all of The DAO tokens and create a different decentralised fund, focusing for ex. on bettering smart contracts security.

As of 29 June, the hard fork option is still hotly debated. We will update this content to reflect developments.

This article was originally written by Rayne Stamboliyska. The last article explained the idea of DAOs, but I think we can’t talk about DAOs without mentioning “The DAO”.

The DAO was the first DAO to run on the Ethereum blockchain, it was built by the Ethereum community to be a decentralized venture capital. The DAO was launched on April 30, 2016. It was controlled and operated by its token holders. For funding, the project raised around 150M$.

In June 2016, a user exploited vulnerability in the code of the smart contract of the DAO and successfully stole 3.6 million Ether, which at the time was worth around 50M$.

In response to the attack, the Ethereum community has decided to do a hard fork (a rule violating change in the blockchain) which reverted the attack and returned the funds. The fork took place on block number 192,000 and led to one of the biggest continuous debates in the blockchain space.

One thing to note is that the funds were subjected to a 28 holding period which means the funds didn’t actually arrive at the attacker, this made the hard fork a lot easier since the attacker was yet unable to spend the funds.

The proposal of doing a ‘hard fork’ led to great controversy in the Ethereum community. The supporting side claimed that the attack was not only unfair but it was also a great threat for the future of the Ethereum project as such a great loss of money for such a large part from the community could make lots of people lose faith in the system. Also, it is ethereally wrong to allow a malicious actor to profit from the hack and it can be very dangerous for the network to leave such an amount in the hands of a malicious actor which in turn can use it to further manipulate the network.

Trending Cryptocurrency Hub Articles:

On the other hand, the opposing side claimed that the blockchain should be immutable and the ‘hard fork’ would not just violate it but may also serve as a precedent in future cases. Furthermore, the entire agenda of the DAO is it should be based on code and changing the code breaks the idea of DAO.

The controversy over the ‘hard fork’ led the Ethereum network to split into 2 chains. The unforked version where the attacker received the funds which called Ethereum Classic, and the forked modified version which kept the original name Ethereum.

The controversy over whether the blockchain should be modified in this type of cases started catching fire again lately when an anonymous developer accidentally exploited a vulnerability in Parity contract and destroyed it. The contract was some kind of a library used by lots of multi-signature wallets for managing their funds. The destruction of the contract left the contracts relying on it futile and the funds in them froze (meaning there is no way to move them). The entire amount lost because of this incident was around 900,000 Ether which was worth 300M$ at the time.

To recover the funds, an EIP (Ethereum Improvement Proposal) was published. EIP999 is a proposal for restoring the contract code through a hard fork. This leads to a debate similar to the DAO one, only now the network is more mature and may be able to continue to operate without recovering the funds.

My personal argument is that as the chain is built and agreed upon by the community, the community should be able to revert transactions in consensus agreement. But as noted here https://ethereum-magicians.org/t/eip-999-restore-contract-code-at-0x863df6bfa4/130/21?u=maurelian a problem is that smaller cases of less influential voices may be treated differently which can make the network unfair.

As I see it, there is no clear right or wrong here as both sides have strong, justified claims and I will not take a side for now but will leave it for your discretion.

Explore Cryptonomy and Follow us on Twitter and Facebook.

This guest article was written by Ben Kaufman, founder of BitCampus.io. The DAO Hack Explained: Unfortunate Take-off of Smart Contracts Osman Gazi Güçlütürk · Follow 8 min read · Aug 1, 2018 -- Share

Logo of the DAO

Smart contracts brought distributed autonomous organizations, aka “DAO”s, to our life. A DAO is another computer code through which a set of smart contracts are connected together and function as a governance mechanism.

In this story I will explore the most famous DAO project, the DAO, and its effects on the smart contract environment. While reading the…. Sometime in the wee hours Friday, a thief made off with $50 million of virtual currency.

The victims are investors in a strange fund called the DAO, or Decentralized Autonomous Organization, who poured more than $150 million of a bitcoin-style currency called Ether into the project.

Code was supposed to eliminate the need to trust humans. But humans, it turns out, are tough to take out of the equation.

The people who created the DAO saw it as a decentralized investment fund. Instead of leaving decisions to a few partners, anyone who invested would have a say in which companies to fund. The more you contributed, the more weight your vote carried. And the distributed structure meant no one could run off with the money.

That was the plan, anyway.

The DAO is built on Ethereum, a system designed for building decentralized applications. Its creators hoped to prove you can build a more democratic financial institution, one without centralized control or human fallibility. Instead, the DAO led to a heist that raises philosophical questions about the viability of such systems. Code was supposed to eliminate the need to trust humans. But humans, it turns out, are tough to take out of the equation.

A Never-Ending ATM

DAO developers and Ethereum enthusiasts are trying to figure out how they might reverse the theft. The good news is that time is on their side. The thief transferred the stolen funds into a clone of the DAO that likely includes code that, as in the original system, delays payouts for a few weeks.

Stephan Tual, the COO of Slock.it, the company that built the DAO, says the thief probably never expected to be able to spend the ether. Each unit of ether is unique and traceable. If the hacker tries to sell any of the stolen ether in a cryptocurrency market, the system will flag it.

"It's like stealing the Mona Lisa," he says. "Great, congratulations, but what do you do with it? You can't sell it, it's too big to be sold."

The DAO is a piece of software known as a "smart contract"--essentially an agreement that enforces itself via code rather than courts. But like all software, smart contracts do exactly what their makers program them to do—and sometimes those programs have unintended consequences.

It's not clear yet exactly how the hack worked, says Andrew Miller, a PhD student at the University of Maryland who studies smart contracts and helped audit Ethereum's code last year. But he says the attacker probably exploited a programming mistake that's exceedingly common in smart contracts.

Let's say you have $50 in the bank and you want to withdraw that from an ATM. You insert your card, punch in your PIN number and then request that $50. Before the machine spits out the cash it will check your balance. Once it spits out the cash, it will debit $50 from that balance. Then the machine asks you if you'd like to process another transaction. You tap "yes" and try to take $50 again. But the ATM sees that your balance is now $0 and refuses. It asks you again if you want to process another transaction, so this time you say "no." Your session ends.

Now imagine that the ATM didn't record your new balance until you ended the session. You could keep requesting $50 again and again until you finally told the machine you didn't want to process any more transactions—or the machine ran out of money.. Thoughts on The DAO Hack

We just lived through the nightmare scenario we were worried about as we called for a moratorium on The DAO: someone exploited a weakness in the code of The DAO to empty out more than 2M ($40M USD) ether.

The exploit seems to have targeted the reentrancy problem in the 'splitDAO' function. The reentrancy problem is related to but distinct from the unchecked-send problem that was discussed on this blog yesterday. Both problems are well-known, identified by Least Authority's audit of the Ethereum virtual machine as problems that can affect applications, as well as Peter Vessenes's recent blog post. In essence, a call that looks like a regular call can easily be turned into a recursive call, and unless the application is coded very carefully, it can be used to make multiple withdrawals when only one should be allowed. It looks like the attacker took advantage of it to withdraw substantial sums.

My immediate reactions to this hack are as follows.

What's a Hack When You Don't Have a Spec? First of all, I'm not even sure that this qualifies as a hack. To label something as a hack or a bug or unwanted behavior, we need to have a specification of the wanted behavior. We had no such specification for The DAO. There is no independent specification for what The DAO is supposed to implement. Heck, there are hardly any comments in The DAO code that document what the developers may have been thinking at the time they wrote the code. The "code was its own documentation," as people say. It was its own fine print. The hacker read the fine print better than most, better than the developers themselves. Had the attacker lost money by mistake, I am sure the devs would have had no difficulty appropriating his funds and saying "this is what happens in the brave new world of programmatic money flows." When he instead emptied out coins from The DAO, the only consistent response is to call it a job well done.

No Safe Haven Right Now You might think that, faced with an attacker on The DAO, you could just take your funds and be safe. But this is not the case here. The DAO devs decided to make it difficult to take funds out of The DAO. So they did not give people the option to "just take funds out." Instead, a DAO investor gets to create a new "child DAO" and move her funds into the child and keep them there for 27 days -- there is no direct withdrawal. The problem is that the child DAO is exactly the same code as the parent, and has the exact same vulnerability. Converting the child back to ether takes another 34 days; replacing the child DAO with an upgraded contract takes a minimum of 7 days. So, the attacker, if he so chose, could stalk people into their children DAOs, and drain them before they got a chance to upgrade their contracts. I don't think he'll do this: if he rose to this level of obnoxiousness, he'd certainly invoke specific censure.

Moving Funds Has A Cost The DAO was not designed to have an easy "update" function. In particular, at this moment, there seems to be no way to take The DAO from its current state, and reinstate it into a newer contract code, keeping its internal state intact. The "extraBalance" account, in particular, is not transferable through "newContract" upgrades. This means that the extraBalance amount, a few million dollars worth, is a writeoff.

The DAO Experiment is Over Practically, this should mark the end of The DAO. The SlockIt folks should work hard to dismantle the fund and return the coins back to the investors in as orderly a fashion as possible.

Is Ethereum/Solidity Suitable for Secure Smart Contracts? It's clear that writing a robust, secure smart contract requires extreme amounts of diligence. It's more similar to writing code for a nuclear power reactor, than to writing loose web code. Yet the current Solidity language and underlying EVM seems designed more for the latter. Some misfeatures are: A good language for writing state machines would ensure that there are no states from which it is impossible to recover.

A good language for writing state machines would make it painfully clear when state transitions can and cannot happen.

A good language for maintaining state machines would provide features for upgrading the security of a live contract.

A good language for writing secure code would make it clear that there are no implicit actions, that code executes plainly, as read. The current language does not fulfill any of these commandments, and in fact, the last one, involving implicit recursive calls, is what did The Dao in. The SlockIt team even had the designer and implementor of Solidity perform a review of their code. If he cannot get something like The DAO to be secure, no one can. A re-think seems called for.

Copycat Attacks The main worry right now involves copycat attacks. Others can learn from this attack and launch the exact same one.

Stopping the Attacker The big unknown is how the ethereum community will react. On the one hand, rolling back the ethereum blockchain will send a terrible message. If contracts can be reverted, then how exactly are smart contracts any better than regular old paper contracts? On the other hand, watching The DAO get drained by a thief is a depressing end to an exciting experiment. There is no good solution here. Practically speaking, the miners will probably put a freeze in effect and provide some time for The DAO investors to withdraw their funds, to minimize heartache. But in the end, there is no outcome that'll make everyone happy.

Looking Forward Smart contracts are and remain an incredibly exciting field. We have only begun to scratch the surface. There can be no birth without pain, no initial foray into the unknown without some setback. I believe that Ethereum overall will emerge from this in a few weeks, having been made much stronger as a result. It will have a newfound direction and charter that involves a slight pivot, away from "let's get DApps at all costs, let's make front-end programmers into smart contract writers," towards "let's build up the science of secure, smart contracts." And that will make everything worth it.

Share on Twitter Share on Twitter

Share on Facebook Share on Facebook

Share on Linkedin Share on Linkedin

Share on Reddit Share on Reddit

Share on E-Mail Share on E-Mail

Please enable JavaScript to view the comments powered by Disqus.

Disqus. Analysis of the DAO exploit

Phil Daian

So I'm sure everyone has heard about the big news surrounding the DAO getting taken to the tune of $150M by a hacker using the recursive Ethereum send exploit.

This post will be the first in what is potentially a series, deconstructing and explaining what went wrong at the technical level while providing a timeline tracing the actions of the attacker back through the blockchain. This first post will focus on how exactly the attacker stole all the money in the DAO.

A Multi-Stage Attack This exploit in the DAO is clearly not trivial; the exact programming pattern that made the DAO vulnerable was not only known, but fixed by the DAO creators themselves in an earlier intended update to the framework's code. Ironically, as they were writing their blog posts and claiming victory, the hacker was preparing and deploying an exploit that targeted the same function they had just fixed to drain the DAO of all its funds. Let's get into the overview of the attack. The attacker was analyzing DAO.sol, and noticed that the 'splitDAO' function was vulnerable to the recursive send pattern we've described above: this function updates user balances and totals at the end, so if we can get any of the function calls before this happens to call splitDAO again, we get the infinite recursion that can be used to move as many funds as we want (code comments are marked with XXXXX, you may have to scroll to see em): function splitDAO ( uint _proposalID , address _newCurator ) noEther onlyTokenholders returns ( bool _success ) { ... uint fundsToBeMoved = ( balances [ msg . sender ] * p . splitData [ 0 ]. splitBalance ) / p . splitData [ 0 ]. totalSupply ; if ( p . splitData [ 0 ]. newDAO . createTokenProxy . value ( fundsToBeMoved )( msg . sender ) == false ) throw ; ... Transfer ( msg . sender , 0 , balances [ msg . sender ]); withdrawRewardFor ( msg . sender ); totalSupply -= balances [ msg . sender ]; balances [ msg . sender ] = 0 ; paidOut [ msg . sender ] = 0 ; return true ; } The basic idea is this: propose a split. Execute the split. When the DAO goes to withdraw your reward, call the function to execute a split before that withdrawal finishes. The function will start running without updating your balance, and the line we marked above as "the attacker wants to run more than once" will run more than once. What does that do? Well, the source code is in TokenCreation.sol, and it transfers tokens from the parent DAO to the child DAO. Basically the attacker is using this to transfer more tokens than they should be able to into their child DAO. How does the DAO decide how many tokens to move? Using the balances array of course: uint fundsToBeMoved = ( balances [ msg . sender ] * p . splitData [ 0 ]. splitBalance ) / p . splitData [ 0 ]. totalSupply ; Because p.splitData[0] is going to be the same every time the attacker calls this function (it's a property of the proposal p, not the general state of the DAO), and because the attacker can call this function from withdrawRewardFor before the balances array is updated, the attacker can get this code to run arbitrarily many times using the described attack, with fundsToBeMoved coming out to the same value each time. The first thing the attacker needed to do to pave the way for his successful exploit was to have the withdraw function for the DAO, which was vulnerable to the critical recursive send exploit, actually run. Let's look at what's required to make that happen in code (from DAO.sol): function withdrawRewardFor ( address _account ) noEther internal returns ( bool _success ) { if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) throw ; uint reward = ( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply - paidOut [ _account ]; if ( ! rewardAccount . payOut ( _account , reward )) throw ; paidOut [ _account ] += reward ; return true ; } If the hacker could get the first if statement to evaluate to false, the statement marked vulnerable would run. When that statements runs, code that looks like this would be called: function payOut ( address _recipient , uint _amount ) returns ( bool ) { if ( msg . sender != owner || msg . value > 0 || ( payOwnerOnly && _recipient != owner )) throw ; if ( _recipient . call . value ( _amount )()) { PayOut ( _recipient , _amount ); return true ; } else { return false ; } Notice how the marked line is exactly the vulnerable code mentioned in the description of the exploit we linked! That line would then send a message from the DAO's contract to "_recipient" (the attacker). "_recipient" would of course contain a default function, that would call splitDAO again with the same parameters as the initial call from the attacker. Remember that because this is all happening from inside withdrawFor from inside splitDAO, the code updating the balances in splitDAO hasn't run. So the split will send more tokens to the child DAO, and then ask for the reward to be withdrawn again. Which will try to send tokens to "_recipient" again, which would again call split DAO before updating the balances array. And so it goes: Propose a split and wait until the voting period expires. (DAO.sol, createProposal) Execute the split. (DAO.sol, splitDAO) Let the DAO send your new DAO its share of tokens. (splitDAO -> TokenCreation.sol, createTokenProxy) Make sure the DAO tries to send you a reward before it updates your balance but after doing (3). (splitDAO -> withdrawRewardFor -> ManagedAccount.sol, payOut) While the DAO is doing (4), have it run splitDAO again with the same parameters as in (2) (payOut -> _recipient.call.value -> _recipient()) The DAO will now send you more child tokens, and go to withdraw your reward before updating your balance. (DAO.sol, splitDAO) Back to (5)! Let the DAO update your balance. Because (7) goes back to (5), it never actually will :-). (Side note: Ethereum's gas mechanics don't save us here. call.value passes on all the gas a transaction is working with by default, unlike the send function. so the code will run as long as the attacker will pay for it, which considering it's a cheap exploit means indefinitely) Armed with this, we can provide a step by step re-trace of how The DAO got emptied out.

Step 1: Proposing the Split The first step towards all of the above is to simply propose a regular split, as we've mentioned. The attacker does this in the blockchain here in DAO Proposal #59, with the title "Lonely, so Lonely". Because of this line: uint constant minSplitDebatePeriod = 1 weeks ; he had to wait a week for the proposal to see approval. No matter, it's just a split proposal like any other! Nobody will look too closely at it, right?

Step 2: Getting the Reward As was neatly explained in one of slock.it's previous posts on the matter, there are no rewards for the DAO to give out yet! (because no rewards were generated). As we mentioned in the overview, the critical lines that need to run here are: function withdrawRewardFor ( address _account ) noEther internal returns ( bool _success ) { if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) throw ; uint reward = ( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply - paidOut [ _account ]; if ( ! rewardAccount . payOut ( _account , reward )) throw ; paidOut [ _account ] += reward ; return true ; } If the hacker could get the first marked line to run, the second marked line will run the default function of his choosing (that calls back to splitDAO as we described previously). Let's deconstruct the first if statement: if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) The balanceOf function is defined in Token.sol, and of course does exactly this: return balances [ _owner ]; The rewardAccount.accumulatedInput() line is evaluated from code in ManagedAccount.sol: uint public accumulatedInput ; Luckily accumulatedInput is oh so simple to manipulate. Just use the default function of the reward account! function () { accumulatedInput += msg . value ; } Not only that, but because there is no logic to decrease accumulatedInput anywhere (it tracks the input the account has gotten from all the transactions ever), all the attacker needs to do is send a few Wei to the reward account and our original condition will not only evaluate to false, but its constituent values will evaluate to the same thing every time it's called: if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) Remember that because balanceOf refers to balances, which never gets updated, and because paidOut and totalSupply also never get updated since that code in splitDAO never actually executes, the attacker gets to claim their tiny share of the reward with no problems. And because they can claim their share of the reward, they can run their default function and reenter back to splitDAO. Whoopsie. But do they actually need to include a reward? Let's look at the line again: if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) What if the reward account balance is 0? Then we get if ( 0 < paidOut [ _account ]) If nothing has ever been paid out, this will always evaluate to false and never throw! Why? The original line is equivalent, after subtracting paidOut from both sides, to: if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply - paidOut [ _account ] < 0 ) where that first part is actually how much is being paid out. So the check is actually: if ( amountToBePaid < 0 ) But if amountToBePaid is 0, the DAO pays you anyway. To me this doesn't make much sense -- why waste the gas in this manner? I think this is why many people assumed the attacker needed a balance in the reward account to proceed with the attack, something they in fact did not require. The attack works the same way with an empty reward account as with a full one! Let's take a look at the DAO's reward address. The DAO accounting documentation from Slockit pegs this address as 0xd2e16a20dd7b1ae54fb0312209784478d069c7b0. Check that account's transactions and you see a pattern: 200 pages of .00000002 ETH transactions to 0xf835a0247b0063c04ef22006ebe57c5f11977cc4 and 0xc0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89, the attacker's two malicious contracts (which we cover later). That's one transaction for each recursive call of withdrawRewardFor, which we described above. So in this case there actually was a balance in the rewards account, and the attacker gets to collect some dust.

Step 3: The Big Short A number of entirely unsubstantiated allegations on social media have pointed to a $3M Ethereum short that occurred on Bitfinex just moments before the attack, claiming this short closed with almost $1M USD of profit. It's obvious to anyone constructing or analyzing this attack that certain properties of the DAO (specifically that any split must be running the same code as the original DAO) require an attacker to wait through the creation period of their child DAO (27 days) before withdrawing any coins in a malicious split. This gives the community time to respond to a theft, through either a soft fork freezing attacker funds or a hard fork rolling back the compromise entirely. Any financially motivated attacker who had attempted their exploit on the testnet would have an incentive to ensure profits regardless of a potential rollback or fork by shorting the underlying token. The staggering drop that resulted within minutes of the smart contract that triggered the malicious split provided an excellent profit opportunity, and while there is no proof the attacker took the profit opportunity, we can at least conclude that after all this effort they would have been stupid not to.

Step 3a: Preventing Exit (Resistance is Futile) Another contingency that the attacker needed to think of is the case that a DAO split occurs before the attacker can finish emptying the DAO. In this case, with another user as sole curator, the attacker would have no access to DAO funds. Unfortunately the attacker is a smart guy: there is evidence that the attacker has voted yes on all split proposals that come to term after his own, making sure that he would hold some tokens in the case of any DAO split. Because of a property of the DAO we'll discuss later in the post, these split DAOs are vulnerable to the same emptying attack we're describing here. All the attacker has to do is sit through the creation period, send some Ether to the reward account, and propose and execute a split by himself away from this new DAO. If he can execute before the curator of this new DAO updates the code to remove the vulnerability, he manages to squash all attempts to get Ether out of the DAO that aren't his own. Notice by the timestamps here that the attacker did this right around the time he started the malicious split, almost as an afterthought. I see this more as an unnecessary middle finger to the DAO than a financially viable attack: having already emptied virtually the entire DAO, going through this effort to pick up any pennies that might be left on the table is probably an attempt to demoralize holders into inaction. Many have concluded, and I agree, that this hints at the attacker's motivations being a complete destruction of the DAO that goes beyond profit taking. While none of us know the truth here, I do recommend applying your own judgment. Interestingly enough, this attack was described by Emin Gün Sirer after it had already occurred on the blockchain, but before the public had noticed.

Step 4: Executing the Split So we've painstakingly described all the boring technical aspects of this attack. Let's get to the fun part, the action: executing the malicious split. The account that executed the transactions behind the split is 0xf35e2cc8e6523d683ed44870f5b7cc785051a77d. The child DAO they sent funds to is 0x304a554a310c7e546dfe434669c62820b7d83490. The proposal was created and initiated by account 0xb656b2a9c3b2416437a811e07466ca712f5a5b5a (you can see the call to createProposal in the blockchain history there). Deconstructing the constructor arguments that created that child DAO leads us to a curator at 0xda4a4626d3e16e094de3225a751aab7128e96526. That smart contract is just a regular multisignature wallet, with most of its past transactions being adding/removing owners and other wallet management tasks. Nothing interesting there. Johannes Pfeffer on Medium has an excellent blockchain-based reconstruction of the transactions involved in the malicious Child DAO. I won't spend too much time on such blockchain analysis, since he's already done a great job. I highly encourage anyone interested to start with that article. In the next article in the series, we'll look at the code from the malicious contract itself (containing the exploit that actually launched the recursive attack). In the interest of expedience of release, we have not yet completed such an analysis.

Step 4a: Extending the Split This step is an update to the original update, and covers how the attacker was able to turn a ~30X amplification attack (due to the max size of Ethereum's stack being capped at 128) to a virtually infinite draining account. Savvy readers of the above may notice that, even after overwhelming the stack and executing many more malicious splits than was required, the hacker would have their balance zeroed out by the code at the end of splitDAO: function splitDAO ( .... withdrawRewardFor ( msg . sender ); totalSupply -= balances [ msg . sender ]; balances [ msg . sender ] = 0 ; paidOut [ msg . sender ] = 0 ; return true ; } So how did the attacker get around this? Thanks to the ability to transfer DAO tokens, he didn't really need to! All he had to do was call the DAO's helpful transfer function at the top of his stack, from his malicious function: function transfer ( address _to , uint256 _amount ) noEther returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; ... By transferring the tokens to a proxy account, the original account would be zeroed out correctly at the end of splitDAO (notice how if A transfers all its money to B, A's account is already zeroed out by transfer before it can be zeroed out by splitDAO). The attacker can then send the money back from the proxy account to the original account and start the whole process again. Even the update to totalSupply in splitDAO is missed, since p.totalSupply[0] is used to calculate the payout, which is a property of the original proposal and only instantiated once before the attack occurs. So the attack size stays constant despite less available ETH in the DAO with every iteration. The evidence of two malicious contracts calling into withdrawRewardFor on the blockchain suggests that the attacker's proxy account was also an attack-enabled contract that simply alternated as the attacker with the original contract. This optimization saves the attacker one transaction per attack cycle, but otherwise appears unnecessary.

Was 1.1 Vulnerable? Because this vulnerability was in withdrawRewardFor, a natural question to ask is whether the DAO 1.1, with the updated function, was still vulnerable to a similar attack. The answer: yes. Check out the updated function (especially the marked lines): function withdrawRewardFor ( address _account ) noEther internal returns ( bool _success ) { if (( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply < paidOut [ _account ]) throw ; uint reward = ( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply - paidOut [ _account ]; reward = rewardAccount . balance < reward ? rewardAccount . balance : reward ; paidOut [ _account ] += reward ; if ( ! rewardAccount . payOut ( _account , reward )) throw ; return true ; } Notice how paidOut is updated before the actual payout is made now. So how does this affect our exploit? Well, the second time getRewardFor is called, from inside the evil second call to splitDAO, this line: uint reward = ( balanceOf ( _account ) * rewardAccount . accumulatedInput ()) / totalSupply - paidOut [ _account ]; will come out to 0. The payOut call will then call _recipient.call.value(0)(), which is the default value for that function, making it equivalent to a call to _recipient . call () Because the attacker paid for a lot of gas when sending his malicious split transaction, the recursive attack is allowed to continue with a vengeance. Realizing they needed a 1.2 6 days after a 1.1, on code designed to be secure for years, is probably why the DAO's puppet masters called it quits.

An Important Takeaway I think the susceptibility of 1.1 to this attack is really interesting: even though withdrawReward for was not vulnerable by itself, and even though splitDAO was not vulnerable without withdrawRewardFor, the combination proves deadly. This is probably why this exploit was missed in review so many times by so many different people: reviewers tend to review functions one at a time, and assume that calls to secure subroutines will operate securely and as intended. In the case of Ethereum, even secure functions that involve sending funds could render your original function as vulnerable to reentrancy. Whether they're functions from the default Solidity libraries or functions that you wrote yourself with security in mind. Special care is required in reviews of Ethereum code to make sure that any functions moving value occur after any state updates whatsoever, otherwise these state values will be necessarily vulnerable to reentrancy.

What's Next? I won't cover the fork debate or what's next for Ethereum and The DAO here. That subject is being beaten to death on every form of social media imaginable. For our series of posts, the next step is to reconstruct the exploit on the TestNet using the DAO 1.0 code, and demonstrate both the code behind the exploit and the mechanism of attack. Please note that if someone beats me to these objectives, I reserve the right to cap the length of the series at one.

More Info The information provided in this post is intended only to provide a broad overview and timeline of the attack, as well as a starting point for analysis. If you have blockchain data or analysis, or contract source code or binary analysis that may have been relevant to the topics described here, please share it by mailing me at phil linuxcom. I will be happy to add it to the post with an acknowledgement in an effort to create a comprehensive reconstruction of the events of the last 24 hours (as of this writing).

Acknowledgements Thanks to Martin Köppelmann on Twitter and in the comments for pointing out this additional detail and correcting my blockchain analysis of the single malicious smart contract. Sincerest thanks to Andrew Miller for reviewing this post, Zikai Alex Wen for spending a few hours chasing decompiled Ethereum contracts with me (with results yet to appear in publication), and Emin Gün Sirer for turning me on to this attack before it went public, and staying up late on a Friday to adapt my post to Markdown and get it published early. Gün, we were so damn close -- sorry it wasn't quite enough this time :).

Share on Twitter Share on Twitter

Share on Facebook Share on Facebook

Share on Linkedin Share on Linkedin

Share on Reddit Share on Reddit

Share on E-Mail Share on E-Mail

Please enable JavaScript to view the comments powered by Disqus.

Disqus. Details Of The DAO Hacking In Ethereum In 2016

Toshendra Kumar Sharma

The DAO hack that threatened everything and affected Ethereum

Do you remember how a decentralized autonomous organization can create with the use of Ethereum? In the year 2016, there was a downfall. A startup was working on a DOA project named DAO hack.

Dao was a model which is programmed and initiated by a start-up firm called Slock it. The primary purpose of this project is to make no person venture capital firm that would allow investors to make decisions through smart contracts.

It’s the DAO that got hacked

The DAO is a DENCENTRALIZED AUTONOMOUS ORGANIZATION – this is an organization where rules by computer programs generate Smart Contracts. Specifically, the DAO was built to be an investment vehicle that funds proposals. It does this by allowing its investors, who hold The DAO Tokens. Let’s call them TDT from this point to vote on proposals. Voting limits future actions so if a TDT holder votes yes or no. They can’t change their vote until the period is has ended.

When it made its 27-day crowd sale, the DAO raised 11.5 million Ether. This had a value of over US 150 million at the time and 16% of the total supply of Ether. Not only is that a lot of money but it was the largest crowdfund in history.

If the proposal on which a TDT holder voted succeeds, the owner can only withdraw their share of Ether balance that is left after the winning project once funded. In contrast, token holders that do not vote can remove from the DAO by initiating a split. Splits take seven days to fork off the funds. Consequently, a division launched by a user seven days ahead of a proposal’s voting deadline can operate without any risk that her funds will spend on that project. The DAO does not permit funds to be withdrawn as Ether directly. Instead, token holders can take their TDT out by a process known as a ‘split’. This is a process that takes 34 days in total to complete and involves creating a new DAO.

One of these flaws is how the DAO acts as a factory for creating child ‘smart contracts’ that ‘split’ off from the main DAO to create a ‘child-DAO.’

Recall that splitting is the only method of extracting one’s Ether holdings from the main DAO contract. This is where the user who splits from the DAO initiates a new DAO contract. In this contract, they will initially be the sole investor and curator. The idea here is that a user can extract her funds by whitelisting a proposal to pay herself the entire contents of her contract, voting on it with 100% support and the obtaining the resources by executing the approved plan.

Even if no action is taken, the attacker will not be able to withdraw any Ether at least for another ~27 days (the creation window for the child DAO).

One solution is a soft fork which will make any operations that make any calls/call codes/delegate calls that reduce the balance of an account with the system.

With the hard fork, a typical Ethereum user will not feel anything from that hard fork, besides a minor client update.

If you are a TDH holder, you can vote ‘yes’ on those split above proposals.

One way you can help mitigate the attack is by spamming the Ethereum network using your Ethereum client. You can use this to spam the chain.. 